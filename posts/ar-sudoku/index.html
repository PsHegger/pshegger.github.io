<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Turning a Camera Feed into a Solved Sudoku | pshegger&#39;s blog</title>
<meta name="keywords" content="programming, android, mlkit, sudoku">
<meta name="description" content="An introduction to a simple application that uses ML Kit &amp; maths to create an augmented reality sudoku solver">
<meta name="author" content="pshegger">
<link rel="canonical" href="https://pshegger.github.io/posts/ar-sudoku/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://pshegger.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://pshegger.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://pshegger.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://pshegger.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://pshegger.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://pshegger.github.io/posts/ar-sudoku/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-NKBPT9CS94"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-NKBPT9CS94');
        }
      </script><meta property="og:url" content="https://pshegger.github.io/posts/ar-sudoku/">
  <meta property="og:site_name" content="pshegger&#39;s blog">
  <meta property="og:title" content="Turning a Camera Feed into a Solved Sudoku">
  <meta property="og:description" content="An introduction to a simple application that uses ML Kit &amp; maths to create an augmented reality sudoku solver">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-08-12T00:00:00+00:00">
    <meta property="article:modified_time" content="2020-08-12T00:00:00+00:00">
    <meta property="article:tag" content="Programming">
    <meta property="article:tag" content="Android">
    <meta property="article:tag" content="Mlkit">
    <meta property="article:tag" content="Sudoku">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Turning a Camera Feed into a Solved Sudoku">
<meta name="twitter:description" content="An introduction to a simple application that uses ML Kit &amp; maths to create an augmented reality sudoku solver">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://pshegger.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Turning a Camera Feed into a Solved Sudoku",
      "item": "https://pshegger.github.io/posts/ar-sudoku/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Turning a Camera Feed into a Solved Sudoku",
  "name": "Turning a Camera Feed into a Solved Sudoku",
  "description": "An introduction to a simple application that uses ML Kit \u0026 maths to create an augmented reality sudoku solver",
  "keywords": [
    "programming", "android", "mlkit", "sudoku"
  ],
  "articleBody": "A few months ago, I stumbled upon a video that led me into a rabbit hole. It resulted in a simple application that overlays a sudoku’s solution into the camera image of the puzzle. This post is about the process of getting to the end result.\nIt all started with the idea of writing a sudoku solver. The first version was ready relatively quickly, but there was one big problem: entering the starting position was slow and tedious. That’s when I realized that I could use the camera on my phone as the input device. I’ve never worked with image processing before, but it sounded like a good challenge, so I dived into it.\nThe case of the slow solver As I mentioned before, I already had a working sudoku solver, but it was not ready for this kind of usage. It was a simple brute-force algorithm that tried every solution and discarded the incorrect ones.\nThe only optimization which was in place is that it only tried the currently possible numbers to every cell. This version solved the New York Times hard sudoku in about 3 seconds on my MacBook Pro, and that’s far from ideal, especially on a phone.\nLuckily I already had an idea in mind. Instead of mindlessly trying every possible number in a cell, we can first fill in the ones where there’s only 1 possible number and run the solver on that version of the sudoku. This small change led to a considerable time saving as this version solved the same sudoku as before in ~300 ms.\nIn the beginning, I thought I’ll write the solver to work like a human would do, so I used sealed classes to store the 3 states of a cell (Empty, Filled, and PossibleNumbers). As the first version of the solver wasn’t using the third state and I wasn’t planning on using it, I changed the cell type to be a nullable integer, null being the empty state and any other value the filled state. Although it wasn’t as big of a time saver as the previous optimization, it also made the solver faster.\nThe third idea was that I could pre-calculate the coordinates for the 3x3 boxes, so we don’t have to do it on the fly. Even though the calculation was only a few steps, we had to do it for every cell in every iteration, which added up in the end, so this change was also a good idea.\nFinally, I rewrote the code from functional to use old-school loops. This way, it was possible to break preemptively from them and save even more time. I’m sure it’s possible to write functional code that behaves the same, but I don’t know enough functional programming for that, so I chose this solution.\nWith these changes, I could shave off a huge amount of time, the final version solved the test puzzle in about 80 ms (and the easy puzzle only took ~12 ms). This is still more than I’d prefer, but I stopped here.\nfun solve(): List { val emptyCells = mutableListOf",
  "wordCount" : "1909",
  "inLanguage": "en",
  "datePublished": "2020-08-12T00:00:00Z",
  "dateModified": "2020-08-12T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "pshegger"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://pshegger.github.io/posts/ar-sudoku/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "pshegger's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://pshegger.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://pshegger.github.io/" accesskey="h" title="pshegger&#39;s blog (Alt + H)">pshegger&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://pshegger.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://pshegger.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Turning a Camera Feed into a Solved Sudoku
    </h1>
    <div class="post-description">
      An introduction to a simple application that uses ML Kit &amp; maths to create an augmented reality sudoku solver
    </div>
    <div class="post-meta"><span title='2020-08-12 00:00:00 +0000 UTC'>August 12, 2020</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;pshegger

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#the-case-of-the-slow-solver" aria-label="The case of the slow solver">The case of the slow solver</a></li>
                <li>
                    <a href="#the-camera-feed" aria-label="The camera feed">The camera feed</a></li>
                <li>
                    <a href="#reading-the-numbers-on-the-image" aria-label="Reading the numbers on the image">Reading the numbers on the image</a></li>
                <li>
                    <a href="#constructing-the-grid" aria-label="Constructing the grid">Constructing the grid</a></li>
                <li>
                    <a href="#adding-the-known-digits" aria-label="Adding the known digits">Adding the known digits</a></li>
                <li>
                    <a href="#refining-the-grid" aria-label="Refining the grid">Refining the grid</a></li>
                <li>
                    <a href="#the-final-steps" aria-label="The final steps">The final steps</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>A few months ago, I stumbled upon a <a href="https://www.youtube.com/watch?v=hAyZ9K2EBF0">video</a> that led me into a rabbit hole. It resulted in a simple application that overlays a sudoku&rsquo;s solution into the camera image of the puzzle. This post is about the process of getting to the end result.</p>
<p>It all started with the idea of writing a sudoku solver. The first version was ready relatively quickly, but there was one big problem: entering the starting position was slow and tedious. That&rsquo;s when I realized that I could use the camera on my phone as the input device. I&rsquo;ve never worked with image processing before, but it sounded like a good challenge, so I dived into it.</p>
<h2 id="the-case-of-the-slow-solver">The case of the slow solver<a hidden class="anchor" aria-hidden="true" href="#the-case-of-the-slow-solver">#</a></h2>
<p>As I mentioned before, I already had a working sudoku solver, but it was not ready for this kind of usage. It was a simple brute-force algorithm that tried every solution and discarded the incorrect ones.</p>
<p>The only optimization which was in place is that it only tried the currently possible numbers to every cell. This version solved the <a href="https://www.nytimes.com/puzzles/sudoku/hard">New York Times hard sudoku</a> in about 3 seconds on my MacBook Pro, and that&rsquo;s far from ideal, especially on a phone.</p>
<p>Luckily I already had an idea in mind. Instead of mindlessly trying every possible number in a cell, we can first fill in the ones where there&rsquo;s only 1 possible number and run the solver on that version of the sudoku. This small change led to a considerable time saving as this version solved the same sudoku as before in ~300 ms.</p>
<p>In the beginning, I thought I&rsquo;ll write the solver to work like a human would do, so I used sealed classes to store the 3 states of a cell (<code>Empty</code>, <code>Filled</code>, and <code>PossibleNumbers</code>). As the first version of the solver wasn&rsquo;t using the third state and I wasn&rsquo;t planning on using it, I changed the cell type to be a nullable integer, <code>null</code> being the empty state and any other value the filled state. Although it wasn&rsquo;t as big of a time saver as the previous optimization, it also made the solver faster.</p>
<p>The third idea was that I could pre-calculate the coordinates for the 3x3 boxes, so we don&rsquo;t have to do it on the fly. Even though the calculation was only a few steps, we had to do it for every cell in every iteration, which added up in the end, so this change was also a good idea.</p>
<p>Finally, I rewrote the code from functional to use old-school loops. This way, it was possible to break preemptively from them and save even more time. I&rsquo;m sure it&rsquo;s possible to write functional code that behaves the same, but I don&rsquo;t know enough functional programming for that, so I chose this solution.</p>
<p>With these changes, I could shave off a huge amount of time, the final version solved the test puzzle in about 80 ms (and the easy puzzle only took ~12 ms). This is still more than I&rsquo;d prefer, but I stopped here.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">solve</span>(): List&lt;Sudoku&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">val</span> emptyCells = mutableListOf&lt;Pair&lt;Int, List&lt;Int&gt;&gt;&gt;()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> cells.indices) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (cells[i] <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> possible = validNumbers(i / <span style="color:#ae81ff">9</span>, i % <span style="color:#ae81ff">9</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (possible.isEmpty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// early return if this state is unsolvable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> emptyList()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (possible.size <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// fill in if there&#39;s only one possible number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#66d9ef">return</span> copyWithValue(i, possible[<span style="color:#ae81ff">0</span>]).solve()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        emptyCells.add(Pair(i, possible))
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (emptyCells.isEmpty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// no more emtpy cells -&gt; we have found a solution
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> listOf(<span style="color:#66d9ef">this</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> emptyCells[<span style="color:#ae81ff">0</span>].let { (cell, possible) <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>      possible.flatMap { n <span style="color:#f92672">-&gt;</span> copyWithValue(cell, n).solve() }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="the-camera-feed">The camera feed<a hidden class="anchor" aria-hidden="true" href="#the-camera-feed">#</a></h2>
<p>The next step was getting the camera feed. For this, I used <a href="https://developer.android.com/training/camerax">CameraX</a>, which makes the Android camera API usable. I still had problems setting it up because even though I used it only a month prior, it had a beta release since, and the API changed significantly, but after a short time, I could make it work.</p>
<h2 id="reading-the-numbers-on-the-image">Reading the numbers on the image<a hidden class="anchor" aria-hidden="true" href="#reading-the-numbers-on-the-image">#</a></h2>
<p>This was the part where I had the least experience. I&rsquo;ve already heard about Google&rsquo;s <a href="https://developers.google.com/ml-kit">ML Kit</a>, but I haven&rsquo;t used it before. After some documentation reading, I found that it&rsquo;s relatively easy to use with CameraX, and the Text Recognition API was exactly what I needed.</p>
<p>After setting it up, I was at a point where I had texts and their coordinates, but I still needed to turn it to a grid of numbers somehow.</p>
<h2 id="constructing-the-grid">Constructing the grid<a hidden class="anchor" aria-hidden="true" href="#constructing-the-grid">#</a></h2>
<p>I knew that the ideal solution would be using ML Kit to find the exact position of the grid on the image, but I wanted to make it work with the information I already had.</p>
<p>The original idea was to assume that most of the image is the sudoku itself. I know it&rsquo;s not the best solution, but that was my first idea, so I went with it.</p>
<p>With this assumption, we can calculate the size of the cells and the middle of each cell. After that, we create a list of cells, where we store the calculated coordinates and the number which should go to that position (currently 0, which means that it&rsquo;s empty).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> cellSize = bmp.width / <span style="color:#ae81ff">9f</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">0.</span>.<span style="color:#ae81ff">8</span>).forEach { row <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    (<span style="color:#ae81ff">0.</span>.<span style="color:#ae81ff">8</span>).forEach { col <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">val</span> cx = col * cellSize + cellSize / <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> cy = row * cellSize + cellSize / <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    fields.add(Field(cx, cy, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here&rsquo;s how the grid looks like according to our first estimate. It is clear that the cells are not placed correctly, but we&rsquo;ll refine them later:</p>
<p><img alt="/img/ar-sudoku/base_grid_dots.png" loading="lazy" src="/img/ar-sudoku/base_grid_dots.png"></p>
<h2 id="adding-the-known-digits">Adding the known digits<a hidden class="anchor" aria-hidden="true" href="#adding-the-known-digits">#</a></h2>
<p>The next step is parsing the output of the text recognizer and adding the digits to our grid. For this, we will parse the recognized text line-by-line (which is a default supported feature of ML Kit). Every <code>Text.Line</code> object has two important things for us: the bounds of the text and the text itself.</p>
<p>First, we have to calculate the width of a single cell. This can be easily done by dividing the length of the line by the number of characters. After that, we can calculate the <code>x</code> coordinate for every number using its index in the found text and the cell width (<code>val cx = box.left + index * fieldWidth + fieldWidth / 2</code>). The <code>y</code> coordinate is simply the middle point between the top and the bottom of the bounds.</p>
<p>The last step is adding the number to our grid. For that, we have to find the cell with the nearest coordinate to our calculated value and update it with the new values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>text.textBlocks.forEach { block <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    block.lines.forEach { line <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>      line.boundingBox<span style="color:#f92672">?.</span>let { box <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> fieldWidth = box.width().toFloat() / line.text.trimmedLength()
</span></span><span style="display:flex;"><span>      line.text.trim().forEachIndexed { index, c <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">val</span> n = <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$c</span><span style="color:#e6db74">&#34;</span>.toIntOrNull()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">val</span> cx = box.left + index * fieldWidth + fieldWidth / <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">val</span> cy = box.top + (box.bottom - box.top) / <span style="color:#ae81ff">2f</span>
</span></span><span style="display:flex;"><span>          fields.indices.minBy { i <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">val</span> cell = fields[i]
</span></span><span style="display:flex;"><span>            (cx - cell.centerX).pow(<span style="color:#ae81ff">2</span>) + (cy - cell.centerY).pow(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>          }<span style="color:#f92672">?.</span>let { nearestIndex <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>              fields[nearestIndex] = Field(cx, cy, n)
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here&rsquo;s a simple visualization of the grid after this step:</p>
<p><img alt="/img/ar-sudoku/vision_dots.png" loading="lazy" src="/img/ar-sudoku/vision_dots.png"></p>
<p>We can see that the numbers do not align with our previously calculated cells, but this is a good thing as we can use it to calculate the correct coordinates for the whole puzzle now.</p>
<h2 id="refining-the-grid">Refining the grid<a hidden class="anchor" aria-hidden="true" href="#refining-the-grid">#</a></h2>
<p>Now that we know where the real numbers are, we can calculate the correct bounds of the whole grid. For this, we first have to find the distance between two numbers in neighboring cells. We will do this by calculating the average <code>x</code> position of the known numbers in each column of the puzzle and finding the first and last column with at least one number in it. We now have the distance between two columns, and we know which columns are they, so we can easily calculate the width of a single cell.</p>
<p>Using the width, we can calculate what should be the coordinate of the first non-empty column, and the difference between that and the previously computed average will give us the left margin. We can calculate the right margin with the same concept, except we should use the last non-empty column.</p>
<p>The process is basically the same for the height of the cell and the top/bottom margin.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">calculateBounds</span>(width: Int, height: Int, fields: List&lt;Field&gt;): RectF? {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> cellXs = (<span style="color:#ae81ff">0.</span>.<span style="color:#ae81ff">8</span>).map { col <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>      (<span style="color:#ae81ff">0.</span>.<span style="color:#ae81ff">8</span>).mapNotNull { row <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> field = fields[row * <span style="color:#ae81ff">9</span> + col]
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">field</span>.<span style="color:#66d9ef">value</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">field</span>.centerX <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>    }.average().toFloat()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">val</span> firstColX = cellXs.indexOfFirst { <span style="color:#66d9ef">it</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0f</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#66d9ef">it</span>.isNaN() }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">val</span> lastColX = cellXs.indexOfLast { <span style="color:#66d9ef">it</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0f</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#66d9ef">it</span>.isNaN() }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (firstColX &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> lastColX &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">val</span> cellWidth = (cellXs[lastColX] - cellXs[firstColX]) / (lastColX - firstColX)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">val</span> marginLeft = cellXs[firstColX] - firstColX * cellWidth - cellWidth / <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">val</span> marginRight = width - cellXs[lastColX] - ((<span style="color:#ae81ff">8</span> - lastColX) * cellWidth) - cellWidth / <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ... repeate with `y` coordinate to find marginTop &amp; marginBottom
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> RectF(marginLeft, marginTop, width - marginRight, height - marginBottom)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img alt="/img/ar-sudoku/refine_dots.png" loading="lazy" src="/img/ar-sudoku/refine_dots.png"></p>
<p>The last step for having the final coordinates of our cells is looping over the grid and updating every empty cell&rsquo;s coordinates.</p>
<h2 id="the-final-steps">The final steps<a hidden class="anchor" aria-hidden="true" href="#the-final-steps">#</a></h2>
<p>Now that we have everything to display our result, there are only a few things left to do.</p>
<p>First of all, we have to check if the recognized numbers are really a sudoku or just some random numbers on the screen. There&rsquo;s currently only a basic check: we count the numbers, and if there&rsquo;s less than 17 of them, we discard everything as that&rsquo;s the minimum number required to have a uniquely solvable sudoku.</p>
<p>If we decide we found a sudoku, we just have to pass it to our solver, render the solution to a bitmap and set it as an overlay over the camera image.</p>
<p><img alt="/img/ar-sudoku/result.gif" loading="lazy" src="/img/ar-sudoku/result.gif"></p>
<p>The application also caches the solved sudoku, so we don&rsquo;t have to find the solution every frame.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>This is the final version I settled with as a proof-of-concept, but I known there are problems with it. The assumption that the camera image only contains the sudoku itself makes using the program harder. I have an idea of how to solve this problem, but I&rsquo;m currently not planning to improve on it.</p>
<p>The other big problem is the check for real sudokus. The current method can only find cases when there are not enough numbers but doesn&rsquo;t filter when there&rsquo;s a recognized number that should not be part of the puzzle. The idea that I have for finding the grid on the image might be a good solution; maybe sometimes I&rsquo;ll explore it better in the future.</p>
<p>Finding a mathematical way to know where to render the solution was fun, but I don&rsquo;t think it&rsquo;s the best way to do it. I think it would be better to train a model that can tell the bounds of the puzzle and use that instead, but as I already mentioned, I wanted this to be a fun exercise and not just putting together things until I got the result I wanted.</p>
<p>Even though most of the code is part of this article, you might want to see the whole thing. In that case, you can find it on <a href="https://github.com/PsHegger/ar-sudoku-solver">GitHub</a>.</p>
<hr>
<p>This post was originally published on <a href="https://www.kotlindevelopment.com/">kotlindevelopment.com</a>. If you liked it please consider visiting and reading some other articles there.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://pshegger.github.io/tags/programming/">Programming</a></li>
      <li><a href="https://pshegger.github.io/tags/android/">Android</a></li>
      <li><a href="https://pshegger.github.io/tags/mlkit/">Mlkit</a></li>
      <li><a href="https://pshegger.github.io/tags/sudoku/">Sudoku</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Turning a Camera Feed into a Solved Sudoku on x"
            href="https://x.com/intent/tweet/?text=Turning%20a%20Camera%20Feed%20into%20a%20Solved%20Sudoku&amp;url=https%3a%2f%2fpshegger.github.io%2fposts%2far-sudoku%2f&amp;hashtags=programming%2candroid%2cmlkit%2csudoku">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Turning a Camera Feed into a Solved Sudoku on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpshegger.github.io%2fposts%2far-sudoku%2f&amp;title=Turning%20a%20Camera%20Feed%20into%20a%20Solved%20Sudoku&amp;summary=Turning%20a%20Camera%20Feed%20into%20a%20Solved%20Sudoku&amp;source=https%3a%2f%2fpshegger.github.io%2fposts%2far-sudoku%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Turning a Camera Feed into a Solved Sudoku on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fpshegger.github.io%2fposts%2far-sudoku%2f&title=Turning%20a%20Camera%20Feed%20into%20a%20Solved%20Sudoku">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Turning a Camera Feed into a Solved Sudoku on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Turning%20a%20Camera%20Feed%20into%20a%20Solved%20Sudoku&u=https%3a%2f%2fpshegger.github.io%2fposts%2far-sudoku%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://pshegger.github.io/">pshegger&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
