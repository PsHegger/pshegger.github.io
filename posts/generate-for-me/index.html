<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>@GenerateForMe | pshegger&#39;s blog</title>
<meta name="keywords" content="programming, kotlin, annotation, kapt">
<meta name="description" content="Annotations are extremely versatile especially if we write our own processor to overcharge our development. Learn how to write one in Kotlin.">
<meta name="author" content="pshegger">
<link rel="canonical" href="https://pshegger.github.io/posts/generate-for-me/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://pshegger.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://pshegger.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://pshegger.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://pshegger.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://pshegger.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://pshegger.github.io/posts/generate-for-me/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-NKBPT9CS94"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-NKBPT9CS94');
        }
      </script><meta property="og:url" content="https://pshegger.github.io/posts/generate-for-me/">
  <meta property="og:site_name" content="pshegger&#39;s blog">
  <meta property="og:title" content="@GenerateForMe">
  <meta property="og:description" content="Annotations are extremely versatile especially if we write our own processor to overcharge our development. Learn how to write one in Kotlin.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-11-11T00:00:00+00:00">
    <meta property="article:modified_time" content="2019-11-11T00:00:00+00:00">
    <meta property="article:tag" content="Programming">
    <meta property="article:tag" content="Kotlin">
    <meta property="article:tag" content="Annotation">
    <meta property="article:tag" content="Kapt">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="@GenerateForMe">
<meta name="twitter:description" content="Annotations are extremely versatile especially if we write our own processor to overcharge our development. Learn how to write one in Kotlin.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://pshegger.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "@GenerateForMe",
      "item": "https://pshegger.github.io/posts/generate-for-me/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "@GenerateForMe",
  "name": "@GenerateForMe",
  "description": "Annotations are extremely versatile especially if we write our own processor to overcharge our development. Learn how to write one in Kotlin.",
  "keywords": [
    "programming", "kotlin", "annotation", "kapt"
  ],
  "articleBody": "Write once, use everywhere Sooner or later every developer meets the following scenario: you have written the same piece of code multiple times, maybe with some minor differences, and you don’t want to do it again. You analyze the situation and decide to create a separate function so the next time you need it you just have to call it. Sometimes it’s not enough so you create a new abstraction layer and write a class which does what you need. But what happens if you cannot create an abstraction which is suitable for you and it’s easy to use whenever you need it. That’s when Annotation Processing comes for your help.\nWhen you write an annotation processor you are creating an application which writes complex code instead of you, but based on your rules. This of course isn’t the solution every time as writing these processors could easily end up taking more time than you can save with it (relevant XKCD), but sometimes it can really help your productivity.\nThe example Let’s write an annotation processor which creates our RecyclerView adapter and view holder. If you’re not an Android developer don’t be alarmed, the same technics can be used for any type of Kotlin code.\nWriting the adapter is usually pretty straightforward, but you have to do it for every model you want to display inside a RecyclerView, and writing it generates a lot of boilerplate. Naturally we can’t eliminate every parts of writing it, but we can make it easier and faster.\nHow to start? Before we do any coding we should plan how our interface will look like for the end user. As we are planning to generate the adapter with the least possible code we should use a single class for the base and its functions will be used to define the bindings between the data and the view. This means that we will need 2 annotations: one for the class which will define the layout file and an other one for the binding functions, which will define the id of the specific view. Let’s call them @ModelBinding and @BindView. Both of them will have one parameter, for @ModelBinding this will be the layout file for the View and for @BindView this will be the ID of the specific View. We will also have a few restriction on where the end user will be able to use these annotations. @ModelBinding will only be usable for classes which has a constructor with a single parameter (this will be the item we will bind to the View) and @BindView will only work for single parameter functions inside the class. Let’s see an example:\n@ModelBinding(R.layout.item_user) class UserBinding(private val user: User) { @BindView(R.id.name) fun bindName(name: TextView) { name.text = user.name } @BindView(R.id.email) fun bindEmail(email: TextView) { email.text = user.email } } This is all the code we will have to write to create an adapter for our User model which displays the user’s name and email address.\nProject setup As we are planning to enchant our existing code with the generator we will be starting by opening the project. If you want to create the generator as a library the steps are almost the same, except we do not have to add our new modules as a dependency.\nFirst we have to create a new (Java library) module for our annotations. This module will only contain our annotation classes, so no dependency is needed (beside Kotlin). After that let’s add our classes.\n// BindView.kt @Target(AnnotationTarget.FUNCTION) @Retention(AnnotationRetention.SOURCE) annotation class BindView(val viewId: Int) // ModelBinding.kt @Target(AnnotationTarget.CLASS) @Retention(AnnotationRetention.SOURCE) annotation class ModelBinding(val layoutId: Int) The next step is creating our generator module. This also has to be a Java library, but it will have significantly more code in it. From this point on we will only be working in this module.\nFirst we have to add a few dependencies:\nimplementation(project(\":annotations\")) implementation(\"com.google.auto.service:auto-service:1.0-rc4\") implementation(\"com.squareup:kotlinpoet:1.3.0\") kapt(\"com.google.auto.service:auto-service:1.0-rc4\") We have to add our previous module as well as Google’s AutoService and KotlinPoet.\nAutoService is a useful tool which generates configuration for ServiceLoader so we don’t have to set up our annotation processor by hand.\nKotlinPoet We will be using KotlinPoet by Square to make our lives easier. It is not required but the alternative would be to write the whole generated code by hand. Let’s take a look at some of its features.\nFileSpec Using KotlinPoet’s FileSpec we get a few advantages. First of all it handles saving the file, we just have to pass an instance of java.io.File to its writeTo method. The second and probably more important feature is that it automatically adds the imports so we don’t have to bother about them.\nval fileBuilder = FileSpec.Builder(\"package\", \"fileName\") // add whatever you need to the file fileBuilder.build().writeTo(outputFile) You can add everything which is valid in a Kotlin file, but the most important for us now is addType. In our case it is used to add our generated classes, but in other cases it can be used with any TypeSpec.\nBuilding a class As mentioned above we will be using TypeSpec for generating our class. I find learning by examples the easiest so let’s see some basic code and understand together what it does.\nTypeSpec.classBuilder(\"Greeter\") .primaryConstructor( FunSpec.constructorBuilder().addParameter(\"name\", STRING).build() ) .addProperty( PropertySpec.builder(\"name\", STRING) .initializer(\"name\") .addModifiers(KModifier.PRIVATE) .build() ) .addFunction( FunSpec.builder(\"greet\") .addStatement(\"println(\\\"Hello $name\\\")\") .build() ) .build() This code will generate the following class:\nclass Greeter(private val name: String) { fun greet() { println(\"Hello $name\") } } So, what’s happening here. In my opinion KotlinPoet’s API is pretty straightforward and reading it makes everything clear but let’s work ourselves through the code together.\nFirst of all we are defining a class called Greeter using TypeSpec.classBuilder. After that we are adding 3 things to the class: a constructor, a property and a function. For this we are using FunSpec for functions (for the constructor we have to specify that it is in fact not a normal function, for this we are using constructorBuilder), and PropertySpec. After everything is added we just call build and we have our class as a TypeSpec. We can then add it to our FileSpec and save it.\nGenerating the ViewHolder Most of the code in this step is easy after learning the basics. We need to create a class which subclasses the RecyclerView.ViewHolder abstract class. It has to have a constructor which accepts a View as a parameter to pass it to the superclass. If we have that all that remains to write is the main part of the ViewHolder which binds the data to the view. We will call this function bind.\nTo generate it we have to iterate over the functions marked with @BindView in the binding class. We can do that using Element.getEnclosedElements() which returns all elements inside an other one, and we can filter for the ones that are methods and has our annotation. After that we have to add each View as a class member for the ViewHolder and will be initialized with the ID which was passed to the annotation as a parameter. We will also have to call every function inside bind.\nfun generateViewHolder(element: Element, itemPack: String, itemClassName: String): TypeSpec { val classBuilder = TypeSpec.classBuilder(\"${itemClassName}ViewHolder\") .primaryConstructor( FunSpec.constructorBuilder() .addParameter(\"itemView\", ClassName(\"android.view\", \"View\")) .build() ) .superclass(ClassName(\"androidx.recyclerview.widget.RecyclerView\", \"ViewHolder\")) .addSuperclassConstructorParameter(\"itemView\") val binderName = getClassName(element) val bindFunBuilder = FunSpec.builder(\"bind\") .addParameter(\"item\", ClassName(itemPack, itemClassName)) .addStatement(\"val binder = ${binderName.canonicalName}(item)\") element.enclosedElements .filter { element -\u003e element.getAnnotation(Bind::class.java) != null \u0026\u0026 element.kind == ElementKind.METHOD \u0026\u0026 (element as ExecutableElement).parameters.size == 1 } .forEach { element -\u003e val bind = element.getAnnotation(Bind::class.java) val p = (element as ExecutableElement).parameters[0] val viewName = p.simpleName.toString() classBuilder.addProperty( PropertySpec.builder( viewName, getClassName(p), KModifier.PRIVATE ) .initializer(\"itemView.findViewById(%L)\", bind.viewId) .build() ) bindFunBuilder.addStatement(\"binder.${element.simpleName}($viewName)\") } return classBuilder.addFunction(bindFunBuilder.build()).build() } If we run it with the previous binding example it will generate the following code (after some formatting):\nclass UserViewHolder(itemView: View) : ViewHolder(itemView) { private val name: TextView = itemView.findViewById(11111) private val email: TextView = itemView.findViewById(22222) fun bind(item: User) { val binder = UserBinding(item) binder.bindName(name) binder.bindEmail(email) } } The view IDs are just examples. When passing them to the annotation we lose the name and can only use the real value, but it’s not a problem, because they represent the same thing.\nGenerating the Adapter We are done with the hard part but we still need to generate the adapter. For this we need to generate a class which overrides the methods of RecyclerView.Adapter and for the real binding we will use our ViewHolder. We already know almost everything to write the code which will generate it, but there is one thing we didn’t discuss yet. We will need to use generic classes which can be achieved by calling parameterizedBy on a ClassName instance. So for example in our case we can create the list of items with the following code:\nClassName(\"kotlin.collections\", \"List\") .parameterizedBy(ClassName(itemPack, itemClassName)) We can then pass it as any other type to KotlinPoet and in the generated code it will show up as List.\nTying it all together The final step in the puzzle is to create our processor. This is the part of the code generator which will be called by kapt and is responsible for handling the annotations.\nWriting the skeleton of the class is self-explanatory. It has to extend the AbstractProcessor class which has only one abstract method: process. For us the second parameter is the more important, which is a RoundEnvironment. With that we can get everything annotated with our ModelBinding annotation. After that we just have to loop through these elements which contains most of the info we will need to use our adapter builder.\nWe also need to use processingEnv which is a protected member of AbstractProcessor. This is the bridge between our processor and the code we are working with. We will use this for 3 things now: getting the folder where we should save our generated files, getting package info about the classes we are working with and printing diagnostic messages.\nKapt will save the directory for generated files into the processing environment’s options with the name kapt.kotlin.generated. We will be also using a simple data class called AdapterInfo to pass every needed info to our code generator classes.\nNow that we have every knowledge let’s see how our final process method looks like:\noverride fun process(annotations: MutableSet\u003cout TypeElement\u003e?, roundEnv: RoundEnvironment): Boolean { val kaptKotlinGeneratedDir = processingEnv.options[\"kapt.kotlin.generated\"] ?: return false roundEnv.getElementsAnnotatedWith(ModelBinding::class.java) .mapNotNull { element -\u003e if (element.kind != ElementKind.CLASS) { processingEnv.messager.printMessage( Diagnostic.Kind.ERROR, \"Only classes can be annotated with @ModelBinding\" ) return@mapNotNull null } generateAdapterInfo(element) } .map { adapterInfo -\u003e val fileName = \"${adapterInfo.itemClassName}Adapter\" val fileBuilder = FileSpec.builder(adapterInfo.pack, fileName) fileBuilder.addType(AdapterBuilder(processingEnv, adapterInfo).build()).build() } .forEach { fileSpec -\u003e fileSpec.writeTo(File(kaptKotlinGeneratedDir)) } return true } Using it We are now finished with the processor and all that left is using it inside our main module. For that we have to add the two new modules as a dependency.\nimplementation(project(\":annotations\")) kapt(project(\":codegen\")) Once they’re added we are ready to use it. All we need is a layout for our recycler item and a RecyclerView. After that we just have to write our class containing our bindings and press build.\nIf we did everything correctly, once the build is finished there will be a newly generated adapter which we can then use with our RecyclerViews.\nSample Code If you would like to have a look at the final version of the code you can do that at https://github.com/PsHegger/recycleradapter-generator/tree/0.1.0.\nIt is also a bit extended and works as a standalone library, so if you’re an Android developer and would like to use it in your project feel free to do so.\nThis post was originally published on kotlindevelopment.com. If you liked it please consider visiting and reading some other articles there.\n",
  "wordCount" : "1933",
  "inLanguage": "en",
  "datePublished": "2019-11-11T00:00:00Z",
  "dateModified": "2019-11-11T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "pshegger"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://pshegger.github.io/posts/generate-for-me/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "pshegger's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://pshegger.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://pshegger.github.io/" accesskey="h" title="pshegger&#39;s blog (Alt + H)">pshegger&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://pshegger.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://pshegger.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      @GenerateForMe
    </h1>
    <div class="post-description">
      Annotations are extremely versatile especially if we write our own processor to overcharge our development. Learn how to write one in Kotlin.
    </div>
    <div class="post-meta"><span title='2019-11-11 00:00:00 +0000 UTC'>November 11, 2019</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;pshegger

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#write-once-use-everywhere" aria-label="Write once, use everywhere">Write once, use everywhere</a></li>
                <li>
                    <a href="#the-example" aria-label="The example">The example</a></li>
                <li>
                    <a href="#how-to-start" aria-label="How to start?">How to start?</a></li>
                <li>
                    <a href="#project-setup" aria-label="Project setup">Project setup</a></li>
                <li>
                    <a href="#kotlinpoet" aria-label="KotlinPoet">KotlinPoet</a><ul>
                        
                <li>
                    <a href="#filespec" aria-label="FileSpec">FileSpec</a></li>
                <li>
                    <a href="#building-a-class" aria-label="Building a class">Building a class</a></li></ul>
                </li>
                <li>
                    <a href="#generating-the-viewholder" aria-label="Generating the ViewHolder">Generating the ViewHolder</a></li>
                <li>
                    <a href="#generating-the-adapter" aria-label="Generating the Adapter">Generating the Adapter</a></li>
                <li>
                    <a href="#tying-it-all-together" aria-label="Tying it all together">Tying it all together</a></li>
                <li>
                    <a href="#using-it" aria-label="Using it">Using it</a></li>
                <li>
                    <a href="#sample-code" aria-label="Sample Code">Sample Code</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="write-once-use-everywhere">Write once, use everywhere<a hidden class="anchor" aria-hidden="true" href="#write-once-use-everywhere">#</a></h2>
<p>Sooner or later every developer meets the following scenario: you have written the same piece of code multiple times, maybe with some minor differences, and you don&rsquo;t want to do it again. You analyze the situation and decide to create a separate function so the next time you need it you just have to call it. Sometimes it&rsquo;s not enough so you create a new abstraction layer and write a class which does what you need. But what happens if you cannot create an abstraction which is suitable for you <em>and</em> it&rsquo;s easy to use whenever you need it. That&rsquo;s when Annotation Processing comes for your help.</p>
<p>When you write an annotation processor you are creating an application which writes complex code instead of you, but based on your rules. This of course isn&rsquo;t the solution every time as writing these processors could easily end up taking more time than you can save with it (<a href="https://xkcd.com/1205/">relevant XKCD</a>), but sometimes it can really help your productivity.</p>
<h2 id="the-example">The example<a hidden class="anchor" aria-hidden="true" href="#the-example">#</a></h2>
<p>Let&rsquo;s write an annotation processor which creates our <code>RecyclerView</code> adapter and view holder. If you&rsquo;re not an Android developer don&rsquo;t be alarmed, the same technics can be used for any type of Kotlin code.</p>
<p>Writing the adapter is usually pretty straightforward, but you have to do it for every model you want to display inside a <code>RecyclerView</code>, and writing it generates a lot of boilerplate. Naturally we can&rsquo;t eliminate every parts of writing it, but we can make it easier and faster.</p>
<h2 id="how-to-start">How to start?<a hidden class="anchor" aria-hidden="true" href="#how-to-start">#</a></h2>
<p>Before we do any coding we should plan how our interface will look like for the end user. As we are planning to generate the adapter with the least possible code we should use a single class for the base and its functions will be used to define the bindings between the data and the view. This means that we will need 2 annotations: one for the class which will define the layout file and an other one for the binding functions, which will define the id of the specific view. Let&rsquo;s call them <em>@ModelBinding</em> and <em>@BindView</em>. Both of them will have one parameter, for <em>@ModelBinding</em> this will be the layout file for the View and for <em>@BindView</em> this will be the ID of the specific View. We will also have a few restriction on where the end user will be able to use these annotations. <em>@ModelBinding</em> will only be usable for classes which has a constructor with a single parameter (this will be the item we will bind to the View) and <em>@BindView</em> will only work for single parameter functions inside the class. Let&rsquo;s see an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@ModelBinding</span>(<span style="color:#a6e22e">R</span>.layout.item_user)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserBinding</span>(<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> user: User) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@BindView</span>(<span style="color:#a6e22e">R</span>.id.name)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">bindName</span>(name: TextView) {
</span></span><span style="display:flex;"><span>        name.text = user.name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@BindView</span>(<span style="color:#a6e22e">R</span>.id.email)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">bindEmail</span>(email: TextView) {
</span></span><span style="display:flex;"><span>        email.text = user.email
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is all the code we will have to write to create an adapter for our User model which displays the user&rsquo;s name and email address.</p>
<h2 id="project-setup">Project setup<a hidden class="anchor" aria-hidden="true" href="#project-setup">#</a></h2>
<p>As we are planning to enchant our existing code with the generator we will be starting by opening the project. If you want to create the generator as a library the steps are almost the same, except we do not have to add our new modules as a dependency.</p>
<p>First we have to create a new (Java library) module for our annotations. This module will only contain our annotation classes, so no dependency is needed (beside Kotlin). After that let&rsquo;s add our classes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#75715e">// BindView.kt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">@Target</span>(<span style="color:#a6e22e">AnnotationTarget</span>.FUNCTION)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Retention</span>(<span style="color:#a6e22e">AnnotationRetention</span>.SOURCE)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">annotation</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BindView</span>(<span style="color:#66d9ef">val</span> viewId: Int)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ModelBinding.kt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">@Target</span>(<span style="color:#a6e22e">AnnotationTarget</span>.CLASS)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Retention</span>(<span style="color:#a6e22e">AnnotationRetention</span>.SOURCE)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">annotation</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ModelBinding</span>(<span style="color:#66d9ef">val</span> layoutId: Int)
</span></span></code></pre></div><p>The next step is creating our generator module. This also has to be a Java library, but it will have significantly more code in it. From this point on we will only be working in this module.</p>
<p>First we have to add a few dependencies:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gradle" data-lang="gradle"><span style="display:flex;"><span>implementation<span style="color:#f92672">(</span>project<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;:annotations&#34;</span><span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>implementation<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;com.google.auto.service:auto-service:1.0-rc4&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>implementation<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;com.squareup:kotlinpoet:1.3.0&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>kapt<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;com.google.auto.service:auto-service:1.0-rc4&#34;</span><span style="color:#f92672">)</span>
</span></span></code></pre></div><p>We have to add our previous module as well as Google&rsquo;s AutoService and KotlinPoet.</p>
<p>AutoService is a useful tool which generates configuration for <code>ServiceLoader</code> so we don&rsquo;t have to set up our annotation processor by hand.</p>
<h2 id="kotlinpoet">KotlinPoet<a hidden class="anchor" aria-hidden="true" href="#kotlinpoet">#</a></h2>
<p>We will be using <a href="https://github.com/square/kotlinpoet">KotlinPoet</a> by Square to make our lives easier. It is not required but the alternative would be to write the whole generated code by hand. Let&rsquo;s take a look at some of its features.</p>
<h3 id="filespec">FileSpec<a hidden class="anchor" aria-hidden="true" href="#filespec">#</a></h3>
<p>Using KotlinPoet&rsquo;s <code>FileSpec</code> we get a few advantages. First of all it handles saving the file, we just have to pass an instance of <code>java.io.File</code> to its <code>writeTo</code> method. The second and probably more important feature is that it automatically adds the imports so we don&rsquo;t have to bother about them.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> fileBuilder = <span style="color:#a6e22e">FileSpec</span>.Builder(<span style="color:#e6db74">&#34;package&#34;</span>, <span style="color:#e6db74">&#34;fileName&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// add whatever you need to the file
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fileBuilder.build().writeTo(outputFile)
</span></span></code></pre></div><p>You can add everything which is valid in a Kotlin file, but the most important for us now is <code>addType</code>. In our case it is used to add our generated classes, but in other cases it can be used with any TypeSpec.</p>
<h3 id="building-a-class">Building a class<a hidden class="anchor" aria-hidden="true" href="#building-a-class">#</a></h3>
<p>As mentioned above we will be using <code>TypeSpec</code> for generating our class. I find learning by examples the easiest so let&rsquo;s see some basic code and understand together what it does.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">TypeSpec</span>.classBuilder(<span style="color:#e6db74">&#34;Greeter&#34;</span>)
</span></span><span style="display:flex;"><span>    .primaryConstructor(
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">FunSpec</span>.constructorBuilder().addParameter(<span style="color:#e6db74">&#34;name&#34;</span>, STRING).build()
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .addProperty(
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">PropertySpec</span>.builder(<span style="color:#e6db74">&#34;name&#34;</span>, STRING)
</span></span><span style="display:flex;"><span>            .initializer(<span style="color:#e6db74">&#34;name&#34;</span>)
</span></span><span style="display:flex;"><span>            .addModifiers(<span style="color:#a6e22e">KModifier</span>.PRIVATE)
</span></span><span style="display:flex;"><span>            .build()
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .addFunction(
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">FunSpec</span>.builder(<span style="color:#e6db74">&#34;greet&#34;</span>)
</span></span><span style="display:flex;"><span>            .addStatement(<span style="color:#e6db74">&#34;println(</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">Hello </span><span style="color:#e6db74">$name</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">)&#34;</span>)
</span></span><span style="display:flex;"><span>            .build()
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .build()
</span></span></code></pre></div><p>This code will generate the following class:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Greeter</span>(<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> name: String) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">greet</span>() {
</span></span><span style="display:flex;"><span>        println(<span style="color:#e6db74">&#34;Hello </span><span style="color:#e6db74">$name</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So, what&rsquo;s happening here. In my opinion KotlinPoet&rsquo;s API is pretty straightforward and reading it makes everything clear but let&rsquo;s work ourselves through the code together.</p>
<p>First of all we are defining a class called <code>Greeter</code> using <code>TypeSpec.classBuilder</code>. After that we are adding 3 things to the class: a constructor, a property and a function. For this we are using <code>FunSpec</code> for functions (for the constructor we have to specify that it is in fact not a normal function, for this we are using <code>constructorBuilder</code>), and <code>PropertySpec</code>. After everything is added we just call build and we have our class as a <code>TypeSpec</code>. We can then add it to our <code>FileSpec</code> and save it.</p>
<h2 id="generating-the-viewholder">Generating the ViewHolder<a hidden class="anchor" aria-hidden="true" href="#generating-the-viewholder">#</a></h2>
<p>Most of the code in this step is easy after learning the basics. We need to create a class which subclasses the <code>RecyclerView.ViewHolder</code> abstract class. It has to have a constructor which accepts a <code>View</code> as a parameter to pass it to the superclass. If we have that all that remains to write is the main part of the <code>ViewHolder</code> which binds the data to the view. We will call this function <code>bind</code>.</p>
<p>To generate it we have to iterate over the functions marked with <code>@BindView</code> in the binding class. We can do that using <code>Element.getEnclosedElements()</code> which returns all elements inside an other one, and we can filter for the ones that are methods and has our annotation. After that we have to add each <code>View</code> as a class member for the <code>ViewHolder</code> and will be initialized with the ID which was passed to the annotation as a parameter. We will also have to call every function inside bind.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">generateViewHolder</span>(element: Element, itemPack: String, itemClassName: String): TypeSpec {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> classBuilder = <span style="color:#a6e22e">TypeSpec</span>.classBuilder(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${itemClassName}</span><span style="color:#e6db74">ViewHolder&#34;</span>)
</span></span><span style="display:flex;"><span>        .primaryConstructor(
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">FunSpec</span>.constructorBuilder()
</span></span><span style="display:flex;"><span>                .addParameter(<span style="color:#e6db74">&#34;itemView&#34;</span>, ClassName(<span style="color:#e6db74">&#34;android.view&#34;</span>, <span style="color:#e6db74">&#34;View&#34;</span>))
</span></span><span style="display:flex;"><span>                .build()
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .superclass(ClassName(<span style="color:#e6db74">&#34;androidx.recyclerview.widget.RecyclerView&#34;</span>, <span style="color:#e6db74">&#34;ViewHolder&#34;</span>))
</span></span><span style="display:flex;"><span>        .addSuperclassConstructorParameter(<span style="color:#e6db74">&#34;itemView&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> binderName = getClassName(element)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> bindFunBuilder = <span style="color:#a6e22e">FunSpec</span>.builder(<span style="color:#e6db74">&#34;bind&#34;</span>)
</span></span><span style="display:flex;"><span>        .addParameter(<span style="color:#e6db74">&#34;item&#34;</span>, ClassName(itemPack, itemClassName))
</span></span><span style="display:flex;"><span>        .addStatement(<span style="color:#e6db74">&#34;val binder = </span><span style="color:#e6db74">${binderName.canonicalName}</span><span style="color:#e6db74">(item)&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    element.enclosedElements
</span></span><span style="display:flex;"><span>        .filter { element <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>            element.getAnnotation(Bind<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>.java) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                            element.kind <span style="color:#f92672">==</span> <span style="color:#a6e22e">ElementKind</span>.METHOD <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                            (element <span style="color:#66d9ef">as</span> ExecutableElement).parameters.size <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        .forEach { element <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> bind = element.getAnnotation(Bind<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>.java)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> p = (element <span style="color:#66d9ef">as</span> ExecutableElement).parameters[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> viewName = p.simpleName.toString()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            classBuilder.addProperty(
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">PropertySpec</span>.builder(
</span></span><span style="display:flex;"><span>                    viewName,
</span></span><span style="display:flex;"><span>                    getClassName(p),
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">KModifier</span>.PRIVATE
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>                    .initializer(<span style="color:#e6db74">&#34;itemView.findViewById(%L)&#34;</span>, bind.viewId)
</span></span><span style="display:flex;"><span>                    .build()
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            bindFunBuilder.addStatement(<span style="color:#e6db74">&#34;binder.</span><span style="color:#e6db74">${element.simpleName}</span><span style="color:#e6db74">(</span><span style="color:#e6db74">$viewName</span><span style="color:#e6db74">)&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> classBuilder.addFunction(bindFunBuilder.build()).build()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we run it with the previous binding example it will generate the following code (after some formatting):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserViewHolder</span>(itemView: View) : ViewHolder(itemView) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> name: TextView = itemView.findViewById(<span style="color:#ae81ff">11111</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> email: TextView = itemView.findViewById(<span style="color:#ae81ff">22222</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">bind</span>(item: User) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> binder = UserBinding(item)
</span></span><span style="display:flex;"><span>        binder.bindName(name)
</span></span><span style="display:flex;"><span>        binder.bindEmail(email)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The view IDs are just examples. When passing them to the annotation we lose the name and can only use the real value, but it&rsquo;s not a problem, because they represent the same thing.</p>
<h2 id="generating-the-adapter">Generating the Adapter<a hidden class="anchor" aria-hidden="true" href="#generating-the-adapter">#</a></h2>
<p>We are done with the hard part but we still need to generate the adapter. For this we need to generate a class which overrides the methods of <code>RecyclerView.Adapter</code> and for the real binding we will use our <code>ViewHolder</code>. We already know almost everything to write the code which will generate it, but there is one thing we didn&rsquo;t discuss yet. We will need to use generic classes which can be achieved by calling <code>parameterizedBy</code> on a <code>ClassName</code> instance. So for example in our case we can create the list of items with the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>ClassName(<span style="color:#e6db74">&#34;kotlin.collections&#34;</span>, <span style="color:#e6db74">&#34;List&#34;</span>)
</span></span><span style="display:flex;"><span>    .parameterizedBy(ClassName(itemPack, itemClassName))
</span></span></code></pre></div><p>We can then pass it as any other type to KotlinPoet and in the generated code it will show up as <code>List&lt;User&gt;</code>.</p>
<h2 id="tying-it-all-together">Tying it all together<a hidden class="anchor" aria-hidden="true" href="#tying-it-all-together">#</a></h2>
<p>The final step in the puzzle is to create our processor. This is the part of the code generator which will be called by kapt and is responsible for handling the annotations.</p>
<p>Writing the skeleton of the class is self-explanatory. It has to extend the <code>AbstractProcessor</code> class which has only one abstract method: <code>process</code>. For us the second parameter is the more important, which is a <code>RoundEnvironment</code>. With that we can get everything annotated with our <code>ModelBinding</code> annotation. After that we just have to loop through these elements which contains most of the info we will need to use our adapter builder.</p>
<p>We also need to use <code>processingEnv</code> which is a protected member of <code>AbstractProcessor</code>. This is the bridge between our processor and the code we are working with. We will use this for 3 things now: getting the folder where we should save our generated files, getting package info about the classes we are working with and printing diagnostic messages.</p>
<p>Kapt will save the directory for generated files into the processing environment&rsquo;s options with the name <code>kapt.kotlin.generated</code>. We will be also using a simple data class called <code>AdapterInfo</code> to pass every needed info to our code generator classes.</p>
<p>Now that we have every knowledge let&rsquo;s see how our final process method looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">process</span>(annotations: MutableSet&lt;<span style="color:#66d9ef">out</span> TypeElement&gt;?, roundEnv: RoundEnvironment): Boolean {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> kaptKotlinGeneratedDir = processingEnv.options[<span style="color:#e6db74">&#34;kapt.kotlin.generated&#34;</span>] <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    roundEnv.getElementsAnnotatedWith(ModelBinding<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>.java)
</span></span><span style="display:flex;"><span>        .mapNotNull { element <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (element.kind <span style="color:#f92672">!=</span> <span style="color:#a6e22e">ElementKind</span>.CLASS) {
</span></span><span style="display:flex;"><span>                processingEnv.messager.printMessage(
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">Diagnostic</span>.<span style="color:#a6e22e">Kind</span>.ERROR,
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;Only classes can be annotated with @ModelBinding&#34;</span>
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span><span style="color:#a6e22e">@mapNotNull</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            generateAdapterInfo(element)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        .map { adapterInfo <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> fileName = <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${adapterInfo.itemClassName}</span><span style="color:#e6db74">Adapter&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> fileBuilder = <span style="color:#a6e22e">FileSpec</span>.builder(adapterInfo.pack, fileName)
</span></span><span style="display:flex;"><span>            fileBuilder.addType(AdapterBuilder(processingEnv, adapterInfo).build()).build()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        .forEach { fileSpec <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>            fileSpec.writeTo(File(kaptKotlinGeneratedDir))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="using-it">Using it<a hidden class="anchor" aria-hidden="true" href="#using-it">#</a></h2>
<p>We are now finished with the processor and all that left is using it inside our main module. For that we have to add the two new modules as a dependency.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gradle" data-lang="gradle"><span style="display:flex;"><span>implementation<span style="color:#f92672">(</span>project<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;:annotations&#34;</span><span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>kapt<span style="color:#f92672">(</span>project<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;:codegen&#34;</span><span style="color:#f92672">))</span>
</span></span></code></pre></div><p>Once they&rsquo;re added we are ready to use it. All we need is a layout for our recycler item and a <code>RecyclerView</code>. After that we just have to write our class containing our bindings and press build.</p>
<p>If we did everything correctly, once the build is finished there will be a newly generated adapter which we can then use with our <code>RecyclerView</code>s.</p>
<h2 id="sample-code">Sample Code<a hidden class="anchor" aria-hidden="true" href="#sample-code">#</a></h2>
<p>If you would like to have a look at the final version of the code you can do that at <a href="https://github.com/PsHegger/recycleradapter-generator/tree/0.1.0">https://github.com/PsHegger/recycleradapter-generator/tree/0.1.0</a>.</p>
<p>It is also a bit extended and works as a standalone library, so if you&rsquo;re an Android developer and would like to use it in your project feel free to do so.</p>
<hr>
<p>This post was originally published on <a href="https://www.kotlindevelopment.com/">kotlindevelopment.com</a>. If you liked it please consider visiting and reading some other articles there.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://pshegger.github.io/tags/programming/">Programming</a></li>
      <li><a href="https://pshegger.github.io/tags/kotlin/">Kotlin</a></li>
      <li><a href="https://pshegger.github.io/tags/annotation/">Annotation</a></li>
      <li><a href="https://pshegger.github.io/tags/kapt/">Kapt</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share @GenerateForMe on x"
            href="https://x.com/intent/tweet/?text=%40GenerateForMe&amp;url=https%3a%2f%2fpshegger.github.io%2fposts%2fgenerate-for-me%2f&amp;hashtags=programming%2ckotlin%2cannotation%2ckapt">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share @GenerateForMe on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpshegger.github.io%2fposts%2fgenerate-for-me%2f&amp;title=%40GenerateForMe&amp;summary=%40GenerateForMe&amp;source=https%3a%2f%2fpshegger.github.io%2fposts%2fgenerate-for-me%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share @GenerateForMe on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fpshegger.github.io%2fposts%2fgenerate-for-me%2f&title=%40GenerateForMe">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share @GenerateForMe on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%40GenerateForMe&u=https%3a%2f%2fpshegger.github.io%2fposts%2fgenerate-for-me%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://pshegger.github.io/">pshegger&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
