<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Procedural Dungeon Generation | pshegger&#39;s blog</title>
<meta name="keywords" content="kotlin, procgen, gamedev">
<meta name="description" content="Procedural generation is the key to writing games with endless content. In this article I show you how I generate a dungeon that can be later used in a game.">
<meta name="author" content="pshegger">
<link rel="canonical" href="https://pshegger.github.io/posts/procedural-dungeon/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://pshegger.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://pshegger.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://pshegger.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://pshegger.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://pshegger.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://pshegger.github.io/posts/procedural-dungeon/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-NKBPT9CS94"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-NKBPT9CS94');
        }
      </script><meta property="og:url" content="https://pshegger.github.io/posts/procedural-dungeon/">
  <meta property="og:site_name" content="pshegger&#39;s blog">
  <meta property="og:title" content="Procedural Dungeon Generation">
  <meta property="og:description" content="Procedural generation is the key to writing games with endless content. In this article I show you how I generate a dungeon that can be later used in a game.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-03-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-03-10T00:00:00+00:00">
    <meta property="article:tag" content="Kotlin">
    <meta property="article:tag" content="Procgen">
    <meta property="article:tag" content="Gamedev">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Procedural Dungeon Generation">
<meta name="twitter:description" content="Procedural generation is the key to writing games with endless content. In this article I show you how I generate a dungeon that can be later used in a game.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://pshegger.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Procedural Dungeon Generation",
      "item": "https://pshegger.github.io/posts/procedural-dungeon/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Procedural Dungeon Generation",
  "name": "Procedural Dungeon Generation",
  "description": "Procedural generation is the key to writing games with endless content. In this article I show you how I generate a dungeon that can be later used in a game.",
  "keywords": [
    "kotlin", "procgen", "gamedev"
  ],
  "articleBody": "Procedural generation is incredible. It is the key to writing games with endless content. Without it, Minecraft couldn’t have (nearly) infinite worlds with infinite terrain. Spelunky would only contain a few rooms, and we could learn the layout and enemy placement instead of learning the game mechanics. These are only a few examples, but there are a lot of games that use this mechanic for generating content.\nIn this article, I’d like to show you my way of generating a random dungeon that can be later used in a game.\nSteps The process consists of multiple steps, each one starting after the previous finished. Let’s have a look at them one-by-one and see how they work.\n1. Generating rooms This is the beginning of everything. We’re generating multiple random-sized rooms that later will be moved to their correct place and filtered.\nFor each room, we will generate a random width and height. To control the sizes, I introduced a minimum and maximum size setting. When we have the size of the room, we have to place them somewhere. For now, we will put all of them in the middle of our map and will later find their correct position.\nI also needed some way of knowing when to stop generating new rooms. For this, I introduced a new setting that tells us the minimum area of the generated rooms. With this, we can stop generating new ones once the sum of their area reaches our given minimum.\nprivate fun generateRooms() { while (rooms.sumOf { it.room.area() } \u003c settings.minimumArea) { val width = rng.nextInt(settings.maxSize - settings.minSize + 1) + settings.minSize val height = rng.nextInt(settings.maxSize - settings.minSize + 1) + settings.minSize val left = (this.width - width) / 2f val top = (this.height - height) / 2f rooms.add(RoomState(Room(Vector(left, top), width, height), RoomState.State.Generated)) } } 2. Finding room placement First, I select a random room, and we mark that as placed. After that, I iterate over all remaining ones and move them toward a random direction until they no longer intersect with any of the already placed rooms. I also added a margin for this to not end up with rooms that are too close to each other.\nprivate fun moveRooms() { rooms[rng.nextInt(rooms.size)].state = RoomState.State.Placed while (rooms.any { it.state == RoomState.State.Generated }) { val movingRoom = rooms.first { it.state == RoomState.State.Generated } val direction = rng.nextDouble() * 2 * Math.PI val moveVector = Vector(cos(direction), sin(direction)) var finalPlace = false while (!finalPlace) { movingRoom.room.topLeft = movingRoom.room.topLeft + moveVector finalPlace = rooms .filter { it.state == RoomState.State.Placed } .none { it.room.intersects(movingRoom.room, settings.roomMargin) } } movingRoom.state = RoomState.State.Placed } } 3. Selecting rooms to keep We have our rooms in the correct position now, but we still have too many of them. Let’s solve this issue by selecting a few to keep and removing the unnecessary ones. For this, I will calculate the average area of the rooms and only keep those larger than the average times a variable ratio.\nprivate fun selectRooms() { val minArea = rooms.map { it.room.area() }.average() * settings.finalAreaRatio rooms.removeIf { it.room.area() \u003c minArea } } 4. Generating a spanning tree for the rooms Next, we will generate a spanning tree of our rooms. We need this to connect our rooms with as few routes as possible.\nTo achieve this, we need a simple graph class capable of storing our edges and calculating the shortest path between two nodes (I’m using Dijkstra’s algorithm for this).\nAs a start, I calculate all possible edges between our rooms. We will have a complete graph with this, and we can now use that to calculate the spanning tree. We will calculate that by adding new edges until their number is less than the number of selected rooms minus one. We consider an edge a new one if there is currently no path between its two ends.\nprivate fun generateSpanningTree() { val graph = Graph(emptyList()) val allEdges = selectedRooms.mapIndexed { i, x -\u003e selectedRooms.mapIndexed { j, y -\u003e if (i \u003c j) Pair(x.room, y.room) else null }.filterNotNull() }.flatten() while (graph.edges.size \u003c selectedRooms.size - 1) { allEdges .filterNot { graph.isRouteAvailable(it.first, it.second) } .sortedBy { it.first.center.distance(it.second.center) } .take(1) .forEach { graph.addEdge(Graph.Edge(it.first, it.second)) } } } 5. Selecting the entrance With the spanning tree generated, we now have the basic structure of our dungeon. For the next step, let’s choose the room where the whole adventure begins. For this, I wanted to find the farthest room away from any leaf node.\nprivate fun selectEntrance() { val graph = Graph(edges) selectedRooms.forEach { it.room.type = Room.RoomType.Room } selectedRooms.maxByOrNull { graph.branchDistance(it.room) } ?.let { it.room.type = Room.RoomType.Entrance } } private fun \u003cT\u003e Graph.branchDistance(n: T, prev: T? = null): Int { val neighborCount = neighbors(n).size if ((prev == null \u0026\u0026 neighborCount \u003e 1) || neighborCount \u003e 2) { return 0 } val next = neighbors(n).filterNot { it.otherEnd(n) == prev }.firstOrNull()?.otherEnd(n) ?: return 1 return branchDistance(next, n) + 1 } 6. Quest room selection For the next step, I’d like to find the room that will contain the quest objective. I thought that this room should be one of the leaves (that’s why I chose the farthest room as the entrance in the previous step), and it should be far from the entrance.\nTo make it more interesting, I decided to not simply use the farthest room from the entrance but to select a random one, weighted by its distance. I also introduced a factor that can be modified to specify how important the distance is.\nprivate fun selectQuestObjective() { val graph = Graph(edges) val entrance = selectedRooms.first { it.room.type == Room.RoomType.Entrance } val distances = mutableListOf",
  "wordCount" : "1545",
  "inLanguage": "en",
  "datePublished": "2022-03-10T00:00:00Z",
  "dateModified": "2022-03-10T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "pshegger"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://pshegger.github.io/posts/procedural-dungeon/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "pshegger's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://pshegger.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://pshegger.github.io/" accesskey="h" title="pshegger&#39;s blog (Alt + H)">pshegger&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://pshegger.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://pshegger.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Procedural Dungeon Generation
    </h1>
    <div class="post-description">
      Procedural generation is the key to writing games with endless content. In this article I show you how I generate a dungeon that can be later used in a game.
    </div>
    <div class="post-meta"><span title='2022-03-10 00:00:00 +0000 UTC'>March 10, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;pshegger

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#steps" aria-label="Steps">Steps</a><ul>
                        
                <li>
                    <a href="#1-generating-rooms" aria-label="1. Generating rooms">1. Generating rooms</a></li>
                <li>
                    <a href="#2-finding-room-placement" aria-label="2. Finding room placement">2. Finding room placement</a></li>
                <li>
                    <a href="#3-selecting-rooms-to-keep" aria-label="3. Selecting rooms to keep">3. Selecting rooms to keep</a></li>
                <li>
                    <a href="#4-generating-a-spanning-tree-for-the-rooms" aria-label="4. Generating a spanning tree for the rooms">4. Generating a spanning tree for the rooms</a></li>
                <li>
                    <a href="#5-selecting-the-entrance" aria-label="5. Selecting the entrance">5. Selecting the entrance</a></li>
                <li>
                    <a href="#6-quest-room-selection" aria-label="6. Quest room selection">6. Quest room selection</a></li>
                <li>
                    <a href="#7-generating-corridors" aria-label="7. Generating corridors">7. Generating corridors</a></li>
                <li>
                    <a href="#8-converting-to-a-tilemap" aria-label="8. Converting to a tilemap">8. Converting to a tilemap</a></li></ul>
                </li>
                <li>
                    <a href="#demo" aria-label="Demo">Demo</a></li>
                <li>
                    <a href="#final-thoughts" aria-label="Final Thoughts">Final Thoughts</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Procedural generation is incredible. It is the key to writing games with endless content. Without it, <a href="https://www.minecraft.net/">Minecraft</a> couldn’t have (nearly) infinite worlds with infinite terrain. <a href="https://spelunkyworld.com/">Spelunky</a> would only contain a few rooms, and we could learn the layout and enemy placement instead of learning the game mechanics. These are only a few examples, but there are a lot of games that use this mechanic for generating content.</p>
<p>In this article, I’d like to show you my way of generating a random dungeon that can be later used in a game.</p>
<h2 id="steps">Steps<a hidden class="anchor" aria-hidden="true" href="#steps">#</a></h2>
<p>The process consists of multiple steps, each one starting after the previous finished. Let’s have a look at them one-by-one and see how they work.</p>
<h3 id="1-generating-rooms">1. Generating rooms<a hidden class="anchor" aria-hidden="true" href="#1-generating-rooms">#</a></h3>
<p>This is the beginning of everything. We’re generating multiple random-sized rooms that later will be moved to their correct place and filtered.</p>
<p>For each room, we will generate a random width and height. To control the sizes, I introduced a minimum and maximum size setting. When we have the size of the room, we have to place them somewhere. For now, we will put all of them in the middle of our map and will later find their correct position.</p>
<p>I also needed some way of knowing when to stop generating new rooms. For this, I introduced a new setting that tells us the minimum area of the generated rooms. With this, we can stop generating new ones once the sum of their area reaches our given minimum.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">generateRooms</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (rooms.sumOf { <span style="color:#66d9ef">it</span>.room.area() } &lt; settings.minimumArea) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> width = rng.nextInt(settings.maxSize - settings.minSize + <span style="color:#ae81ff">1</span>) + settings.minSize
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> height = rng.nextInt(settings.maxSize - settings.minSize + <span style="color:#ae81ff">1</span>) + settings.minSize
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> left = (<span style="color:#66d9ef">this</span>.width - width) / <span style="color:#ae81ff">2f</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> top = (<span style="color:#66d9ef">this</span>.height - height) / <span style="color:#ae81ff">2f</span>
</span></span><span style="display:flex;"><span>        rooms.add(RoomState(Room(Vector(left, top), width, height), <span style="color:#a6e22e">RoomState</span>.<span style="color:#a6e22e">State</span>.Generated))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2-finding-room-placement">2. Finding room placement<a hidden class="anchor" aria-hidden="true" href="#2-finding-room-placement">#</a></h3>
<p>First, I select a random room, and we mark that as placed. After that, I iterate over all remaining ones and move them toward a random direction until they no longer intersect with any of the already placed rooms. I also added a margin for this to not end up with rooms that are too close to each other.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">moveRooms</span>() {
</span></span><span style="display:flex;"><span>    rooms[rng.nextInt(rooms.size)].state = <span style="color:#a6e22e">RoomState</span>.<span style="color:#a6e22e">State</span>.Placed
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (rooms.any { <span style="color:#66d9ef">it</span>.state <span style="color:#f92672">==</span> <span style="color:#a6e22e">RoomState</span>.<span style="color:#a6e22e">State</span>.Generated }) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> movingRoom = rooms.first { <span style="color:#66d9ef">it</span>.state <span style="color:#f92672">==</span> <span style="color:#a6e22e">RoomState</span>.<span style="color:#a6e22e">State</span>.Generated }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> direction = rng.nextDouble() * <span style="color:#ae81ff">2</span> * <span style="color:#a6e22e">Math</span>.PI
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> moveVector = Vector(cos(direction), sin(direction))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> finalPlace = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (!finalPlace) {
</span></span><span style="display:flex;"><span>            movingRoom.room.topLeft = movingRoom.room.topLeft + moveVector
</span></span><span style="display:flex;"><span>            finalPlace = rooms
</span></span><span style="display:flex;"><span>                .filter { <span style="color:#66d9ef">it</span>.state <span style="color:#f92672">==</span> <span style="color:#a6e22e">RoomState</span>.<span style="color:#a6e22e">State</span>.Placed }
</span></span><span style="display:flex;"><span>                .none { <span style="color:#66d9ef">it</span>.room.intersects(movingRoom.room, settings.roomMargin) }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        movingRoom.state = <span style="color:#a6e22e">RoomState</span>.<span style="color:#a6e22e">State</span>.Placed
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3-selecting-rooms-to-keep">3. Selecting rooms to keep<a hidden class="anchor" aria-hidden="true" href="#3-selecting-rooms-to-keep">#</a></h3>
<p>We have our rooms in the correct position now, but we still have too many of them. Let’s solve this issue by selecting a few to keep and removing the unnecessary ones. For this, I will calculate the average area of the rooms and only keep those larger than the average times a variable ratio.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">selectRooms</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> minArea = rooms.map { <span style="color:#66d9ef">it</span>.room.area() }.average() * settings.finalAreaRatio
</span></span><span style="display:flex;"><span>    rooms.removeIf { <span style="color:#66d9ef">it</span>.room.area() &lt; minArea }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="4-generating-a-spanning-tree-for-the-rooms">4. Generating a spanning tree for the rooms<a hidden class="anchor" aria-hidden="true" href="#4-generating-a-spanning-tree-for-the-rooms">#</a></h3>
<p>Next, we will generate a spanning tree of our rooms. We need this to connect our rooms with as few routes as possible.</p>
<p>To achieve this, we need a simple graph class capable of storing our edges and calculating the shortest path between two nodes (I’m using <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra’s algorithm</a> for this).</p>
<p>As a start, I calculate all possible edges between our rooms. We will have a complete graph with this, and we can now use that to calculate the spanning tree. We will calculate that by adding new edges until their number is less than the number of selected rooms minus one. We consider an edge a new one if there is currently no path between its two ends.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">generateSpanningTree</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> graph = Graph&lt;Room&gt;(emptyList())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> allEdges = selectedRooms.mapIndexed { i, x <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>        selectedRooms.mapIndexed { j, y <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i &lt; j) Pair(x.room, y.room) <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>        }.filterNotNull()
</span></span><span style="display:flex;"><span>    }.flatten()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (graph.edges.size &lt; selectedRooms.size - <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        allEdges
</span></span><span style="display:flex;"><span>            .filterNot { graph.isRouteAvailable(<span style="color:#66d9ef">it</span>.first, <span style="color:#66d9ef">it</span>.second) }
</span></span><span style="display:flex;"><span>            .sortedBy { <span style="color:#66d9ef">it</span>.first.center.distance(<span style="color:#66d9ef">it</span>.second.center) }
</span></span><span style="display:flex;"><span>            .take(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            .forEach { graph.addEdge(<span style="color:#a6e22e">Graph</span>.Edge(<span style="color:#66d9ef">it</span>.first, <span style="color:#66d9ef">it</span>.second)) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="5-selecting-the-entrance">5. Selecting the entrance<a hidden class="anchor" aria-hidden="true" href="#5-selecting-the-entrance">#</a></h3>
<p>With the spanning tree generated, we now have the basic structure of our dungeon. For the next step, let’s choose the room where the whole adventure begins. For this, I wanted to find the farthest room away from any leaf node.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">selectEntrance</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> graph = Graph(edges)
</span></span><span style="display:flex;"><span>    selectedRooms.forEach { <span style="color:#66d9ef">it</span>.room.type = <span style="color:#a6e22e">Room</span>.<span style="color:#a6e22e">RoomType</span>.Room }
</span></span><span style="display:flex;"><span>    selectedRooms.maxByOrNull { graph.branchDistance(<span style="color:#66d9ef">it</span>.room) }
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">?.</span>let { <span style="color:#66d9ef">it</span>.room.type = <span style="color:#a6e22e">Room</span>.<span style="color:#a6e22e">RoomType</span>.Entrance }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> &lt;<span style="color:#a6e22e">T</span>&gt; <span style="color:#a6e22e">Graph</span>&lt;T&gt;.branchDistance(n: T, prev: T? = <span style="color:#66d9ef">null</span>): Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> neighborCount = neighbors(n).size
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((prev <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> neighborCount &gt; <span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span> neighborCount &gt; <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> next = neighbors(n).filterNot { <span style="color:#66d9ef">it</span>.otherEnd(n) <span style="color:#f92672">==</span> prev }.firstOrNull()<span style="color:#f92672">?.</span>otherEnd(n)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">?:</span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> branchDistance(next, n) + <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="6-quest-room-selection">6. Quest room selection<a hidden class="anchor" aria-hidden="true" href="#6-quest-room-selection">#</a></h3>
<p>For the next step, I’d like to find the room that will contain the quest objective. I thought that this room should be one of the leaves (that’s why I chose the farthest room as the entrance in the previous step), and it should be far from the entrance.</p>
<p>To make it more interesting, I decided to not simply use the farthest room from the entrance but to select a random one, weighted by its distance. I also introduced a factor that can be modified to specify how important the distance is.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">selectQuestObjective</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> graph = Graph(edges)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> entrance = selectedRooms.first { <span style="color:#66d9ef">it</span>.room.type <span style="color:#f92672">==</span> <span style="color:#a6e22e">Room</span>.<span style="color:#a6e22e">RoomType</span>.Entrance }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> distances = mutableListOf&lt;Pair&lt;RoomState, Int&gt;&gt;()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    selectedRooms
</span></span><span style="display:flex;"><span>        .filter { <span style="color:#66d9ef">it</span>.room.type <span style="color:#f92672">==</span> <span style="color:#a6e22e">Room</span>.<span style="color:#a6e22e">RoomType</span>.Room <span style="color:#f92672">&amp;&amp;</span> graph.neighbors(<span style="color:#66d9ef">it</span>.room).size <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> }
</span></span><span style="display:flex;"><span>        .forEach { roomState <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> distance = graph.shortestPath(entrance.room, roomState.room)
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">?.</span>let { <span style="color:#66d9ef">it</span>.size - <span style="color:#ae81ff">1</span> } <span style="color:#f92672">?:</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> weight = settings.questObjectiveDistanceFactor.toDouble()
</span></span><span style="display:flex;"><span>                .pow(distance.toDouble()).roundToInt()
</span></span><span style="display:flex;"><span>            distances.add(Pair(roomState, weight))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> questObjective = distances.weightedRandom(rng)
</span></span><span style="display:flex;"><span>    selectedRooms
</span></span><span style="display:flex;"><span>        .first { <span style="color:#66d9ef">it</span> <span style="color:#f92672">==</span> questObjective}
</span></span><span style="display:flex;"><span>        .room.type = <span style="color:#a6e22e">Room</span>.<span style="color:#a6e22e">RoomType</span>.QuestObjective
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="7-generating-corridors">7. Generating corridors<a hidden class="anchor" aria-hidden="true" href="#7-generating-corridors">#</a></h3>
<p>Currently, the rooms are not connected; we just have a graph telling us which of them should be neighbors. To change this, let’s generate some corridors between them.</p>
<p>I iterated over the rooms and checked their neighbors one by one. For each neighbor, I had to find the direction they were in relative to the current room. After that, I knew which sides of the rooms were facing each other so I could check if there were any overlapping regions of those sides. I also added some margin to prevent the corridors from being generated in the room&rsquo;s corner.</p>
<p>At this point, there were two possibilities: there is an overlap where I can put the corridor (red on the image), or there isn’t (blue on the image).</p>
<p><img alt="/img/procedural-dungeon/coridor_types.png" loading="lazy" src="/img/procedural-dungeon/coridor_types.png"></p>
<p>The first one is simple, just select a suitable location and add a corridor there.</p>
<p>The second one is more problematic. In this case, I had to find the side closest to the current room (top, in the example above) and choose a point there. Then I chose a point on the current room and added two separate corridors.</p>
<h3 id="8-converting-to-a-tilemap">8. Converting to a tilemap<a hidden class="anchor" aria-hidden="true" href="#8-converting-to-a-tilemap">#</a></h3>
<p>Now that we have everything generated, there’s only one thing left to do. We should convert our rooms and corridors into a more usable format.</p>
<p>First, I had to find the size of the map. This was an easy task, I just had to find the minimum and the maximum of every room&rsquo;s x and y coordinate. Once I got that, I split the whole area into squares and looped over them. For every square, I checked if it intersects with any room or corridor, and if there was an intersection, I set the tile type accordingly.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">generateTileMap</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> minX = rooms.minOf { <span style="color:#66d9ef">it</span>.room.left }.roundToInt()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> maxX = rooms.maxOf { <span style="color:#66d9ef">it</span>.room.right }.roundToInt()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> minY = rooms.minOf { <span style="color:#66d9ef">it</span>.room.top }.roundToInt()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> maxY = rooms.maxOf { <span style="color:#66d9ef">it</span>.room.bottom }.roundToInt()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> tileMap = TileMap(maxX - minX, maxY - minY)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span> until (tileMap.width * tileMap.height)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> x = i % tileMap.width
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> y = i / tileMap.width
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> tileLeft = (x + minX).toFloat()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> tileTop = (y + minY).toFloat()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> tileRect = RectF(tileLeft, tileTop, tileLeft + <span style="color:#ae81ff">1</span>, tileTop + <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> intersectedRoom = rooms.firstOrNull { <span style="color:#66d9ef">it</span>.room.getRect().intersect(tileRect) }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> intersectedCorridor = corridors.firstOrNull { <span style="color:#66d9ef">it</span>.getRect().intersect(tileRect) }
</span></span><span style="display:flex;"><span>        tileMap[x, y] = <span style="color:#66d9ef">when</span> {
</span></span><span style="display:flex;"><span>            intersectedRoom <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">when</span> (intersectedRoom.room.type) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Room</span>.<span style="color:#a6e22e">RoomType</span>.Room <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">TileMap</span>.<span style="color:#a6e22e">TileType</span>.Room
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Room</span>.<span style="color:#a6e22e">RoomType</span>.Entrance <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">TileMap</span>.<span style="color:#a6e22e">TileType</span>.StartRoom
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Room</span>.<span style="color:#a6e22e">RoomType</span>.QuestObjective <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">TileMap</span>.<span style="color:#a6e22e">TileType</span>.QuestRoom
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            intersectedCorridor <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">TileMap</span>.<span style="color:#a6e22e">TileType</span>.Corridor
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">TileMap</span>.<span style="color:#a6e22e">TileType</span>.Void
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="demo">Demo<a hidden class="anchor" aria-hidden="true" href="#demo">#</a></h2>
<p><img alt="/img/procedural-dungeon/dungeon.gif" loading="lazy" src="/img/procedural-dungeon/dungeon.gif"></p>
<h2 id="final-thoughts">Final Thoughts<a hidden class="anchor" aria-hidden="true" href="#final-thoughts">#</a></h2>
<p>Now that we’re done with the generation, there are a few things I wanted to mention.</p>
<p>You may have seen that I used a variable called <code>rng</code> multiple times during the examples. This is, of course, a random number generator that is initialized at the beginning and then used for every step. This way, we can set a seed to the generator, and we will always get the same end result.</p>
<p>The source code for this article is available on <a href="https://github.com/PsHegger/playground/blob/master/app/src/main/java/pshegger/github/io/playground/gamedev/algorithms/dungeon/DungeonGenerator.kt">GitHub</a>, but if you check it, you may see that it differs from the ones presented here. This is because that code is structured in a way that makes it easier to visualize the process, but that doesn’t change the theory behind this whole process, the end result will be the same in both versions.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://pshegger.github.io/tags/kotlin/">Kotlin</a></li>
      <li><a href="https://pshegger.github.io/tags/procgen/">Procgen</a></li>
      <li><a href="https://pshegger.github.io/tags/gamedev/">Gamedev</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Procedural Dungeon Generation on x"
            href="https://x.com/intent/tweet/?text=Procedural%20Dungeon%20Generation&amp;url=https%3a%2f%2fpshegger.github.io%2fposts%2fprocedural-dungeon%2f&amp;hashtags=kotlin%2cprocgen%2cgamedev">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Procedural Dungeon Generation on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpshegger.github.io%2fposts%2fprocedural-dungeon%2f&amp;title=Procedural%20Dungeon%20Generation&amp;summary=Procedural%20Dungeon%20Generation&amp;source=https%3a%2f%2fpshegger.github.io%2fposts%2fprocedural-dungeon%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Procedural Dungeon Generation on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fpshegger.github.io%2fposts%2fprocedural-dungeon%2f&title=Procedural%20Dungeon%20Generation">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Procedural Dungeon Generation on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Procedural%20Dungeon%20Generation&u=https%3a%2f%2fpshegger.github.io%2fposts%2fprocedural-dungeon%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://pshegger.github.io/">pshegger&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
