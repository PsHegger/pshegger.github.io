<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>RenderScript is Still alive | pshegger&#39;s blog</title>
<meta name="keywords" content="programming, android, renderscript, parallelism">
<meta name="description" content="RenderScript is a great way to compute large amount of data, so let&#39;s discover together what it is and when should it be considered.">
<meta name="author" content="pshegger">
<link rel="canonical" href="https://pshegger.github.io/posts/renderscript/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://pshegger.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://pshegger.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://pshegger.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://pshegger.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://pshegger.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://pshegger.github.io/posts/renderscript/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-NKBPT9CS94"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-NKBPT9CS94');
        }
      </script><meta property="og:url" content="https://pshegger.github.io/posts/renderscript/">
  <meta property="og:site_name" content="pshegger&#39;s blog">
  <meta property="og:title" content="RenderScript is Still alive">
  <meta property="og:description" content="RenderScript is a great way to compute large amount of data, so let&#39;s discover together what it is and when should it be considered.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-02-29T00:00:00+00:00">
    <meta property="article:modified_time" content="2020-02-29T00:00:00+00:00">
    <meta property="article:tag" content="Programming">
    <meta property="article:tag" content="Android">
    <meta property="article:tag" content="Renderscript">
    <meta property="article:tag" content="Parallelism">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RenderScript is Still alive">
<meta name="twitter:description" content="RenderScript is a great way to compute large amount of data, so let&#39;s discover together what it is and when should it be considered.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://pshegger.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "RenderScript is Still alive",
      "item": "https://pshegger.github.io/posts/renderscript/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RenderScript is Still alive",
  "name": "RenderScript is Still alive",
  "description": "RenderScript is a great way to compute large amount of data, so let's discover together what it is and when should it be considered.",
  "keywords": [
    "programming", "android", "renderscript", "parallelism"
  ],
  "articleBody": "I’m sure for most of you it’s not a surprise, but I also think that there are people out there who either doesn’t know what it is or simply tends to forget about it. The aim of this article is to show these people what it is and why should they use it.\nSo, what is RenderScript? RenderScript is an Android framework which can be used for running computationally heavy tasks at high performance. You will get the most benefit on using it for tasks which require a lot of computation that can be parallelized, as the framework will run your code on every available CPU and GPU cores.\nThe first step when writing a task for RenderScript is writing the script file. This file will contain your kernel(s) and everything else needed to compute your result. The kernel is the function which will be executed on your input data in parallel. There are two type of kernels: mapping and reduction, but in this article we will only discuss the former one.\nTesting method As I mentioned before RenderScript is excellent at performing computationally heavy tasks and to demonstrate that I created a simple test application. For this test we will be generating an image of the Mandelbrot set using different methods. Our first version will be written in Kotlin and will not contain any optimization. The second version will still be in Kotlin but we will try to use it’s built-in features to parallelize the computation. Lastly we will have a version written in RenderScript.\nMandelbrot Generating an image of the Mandelbrot set is fairly easy, but it requires a lot of time. All we have to do is calculate for every pixel whether the function f(z) = z*z + c (where z=0+0i and c is the coordinate of the pixel mapped to the complex plane) goes to infinity or not.\nAs there is no simple way to decide that in practice we usually run a predetermined number of iterations and see if the result leaves a predetermined neighborhood of 0. This means that we can make more precise estimates with choosing a higher iteration count, but it will also slow down the process.\nAfter that we just have to take the number of iterations it took to leave the neighborhood and color the pixel accordingly.\nKotlin - the easy one With this knowledge we can easily write a method which calculates the color for a given coordinate.\nprotected fun calculatePoint(x: Int, y: Int, rect: RectF): Int { val cr = rect.left + (rect.right - rect.left) * (x / width.toDouble()) val ci = rect.top + (rect.bottom - rect.top) * (y / height.toDouble()) var zr = 0.0 var zi = 0.0 var i = 0 while (i \u003c MainActivity.MAX_ITER \u0026\u0026 zr * zr + zi * zi \u003c 4) { val nzr = zr * zr - zi * zi + cr val nzi = 2 * zr * zi + ci zr = nzr zi = nzi i++ } val hue = 360 * i.toFloat() / MainActivity.MAX_ITER val sat = 1f val value = if (i \u003c MainActivity.MAX_ITER) 1f else 0f return Color.HSVToColor(floatArrayOf(hue, sat, value)) } This function can be called with the coordinate of the pixel we want to calculate (x and y) and the specific area of the plane we want to display currently (rect). Using these inputs we can then calculate the coordinate on the plane (crand ci). We could also use some complex number class, but from my experience that leads to a performance drop so we stick to calculating the real and imaginary part separately. After that we just have to loop until we either reach the maximum iteration count or leave the neighborhood of 0.\nThe last step is coloring the pixel. For that the easiest way to do is using the HSV color model as you can see in the code above.\nNow that we have everything to calculate the color of one pixel all we have to do is looping over every pixel of the output image and coloring it.\nKotlin Parallel - the complicated one For this version will use the same function to calculate the color of one pixel, but we will split the output to multiple regions and calculate them in parallel. The number of partitions must equal to the number of threads we are using for calculation, but other than that we can split any way we would like to.\nTo determine the number of threads we will use Runtime.getRuntime().availableProcessors() - 1. The -1 ensures that we have one core for our main thread. When we have the number of threads we create a CoroutineDispatcher and launch a new scope using that as it’s context.\nAt this point we have to loop through our partitions and use CoroutineScope.launch to start the calculation on it’s own thread. This calculation is the same as before, but we’re just calculating the points for the given region and not for the whole image.\noverride suspend fun generate(buffer: Bitmap, rect: RectF) { val numThreads = Runtime.getRuntime().availableProcessors() - 1 val context = Executors.newFixedThreadPool(numThreads).asCoroutineDispatcher() var h = sqrt(numThreads.toDouble()).toInt() while (numThreads % h != 0) h-- val w = numThreads / h val segWidth = width / w val segHeight = height / h val canvas = Canvas(buffer) val calculation = CoroutineScope(context).launch { for (mod in (0 until numThreads)) { val segX = mod % w val segY = mod / w val segXStart = segWidth * segX val segXEnd = segWidth * (segX + 1) val segYStart = segHeight * segY val segYEnd = segHeight * (segY + 1) val paint = Paint() launch { for (y in (segYStart until segYEnd)) { for (x in (segXStart until segXEnd)) { val result = calculatePoint(x, y, rect) paint.color = result canvas.drawPoint(x.toFloat(), y.toFloat(), paint) } } } } } calculation.join() } RenderScript - the fast one As the previous example shows it can be pretty tricky to parallelize our computations. We have to manually create our threads and feed them the correct values. But this is where RenderScript comes to rescue us.\nRenderScript will automatically manage the parallelization, all we have to do is write the function which will be executed for every input data (this will be our kernel). The language is a derivative of C99 so some familiarity with that is required to use it.\nFor our example all we have to write is a simple script which contains every input we will need for the calculation (width/height of the output image, the area of the plane we want to calculate and the number of iterations) and our kernel, which will be basically the same we have written in Kotlin to calculate the color of a single point. (We will also have to write a color converter, but that’s only specific for this example.)\n#pragma version(1) #pragma rs_fp_full #pragma rs java_package_name(io.github.pshegger.playground.rsperformance) int width, height; float left, right, top, bottom; int maxIterations = 128; static uchar4 getColor(int i) { float hue = 360 * (float) i / maxIterations; float sat = 1; float val = (i \u003c maxIterations) ? 1 : 0; float c = val * sat; float k = hue / 60; float kmod = fmod(k, 2); float kmodAbs = (kmod - 1 \u003c 0) ? -(kmod - 1) : (kmod - 1); float x = c * (1 - kmodAbs); float r1 = 0, g1 = 0, b1 = 0; if(k\u003e=0 \u0026\u0026 k\u003c=1) { r1=c; g1=x; } if(k\u003e1 \u0026\u0026 k\u003c=2) { r1=x; g1=c; } if(k\u003e2 \u0026\u0026 k\u003c=3) { g1=c; b1=x; } if(k\u003e3 \u0026\u0026 k\u003c=4) { g1=x; b1=c; } if(k\u003e4 \u0026\u0026 k\u003c=5) { r1=x; b1=c; } if(k\u003e5 \u0026\u0026 k\u003c=6) { r1=c; b1=x; } float m = val - c; return rsPackColorTo8888(r1 + m, g1 + m, b1 + m); } uchar4 RS_KERNEL mandelbrot(uchar4 in, uint32_t x, uint32_t y) { float nzr, nzi; float zr = 0, zi = 0; float cr = left + (right - left) * (x / (double) width); float ci = top + (bottom - top) * (y / (double) height); int i = 0; while (i \u003c maxIterations \u0026\u0026 zr * zr + zi * zi \u003c 4) { nzr = zr * zr - zi * zi + cr; nzi = 2 * zr * zi + ci; zr = nzr; zi = nzi; i++; } return getColor(i); } As you can see the kernel (marked with RS_KERNEL) is basically the same as was before with just some minor changes required by the language. It is also worth noting that the kernel’s x and y parameter will not be provided by us, but the framework.\nWe have to put this file inside it’s own directory located at app/src/main/rs and we will call it mandelbrot.rs. After saving we can build the project so the required java files will be generated and after it’s finished we can start using it in our application.\nThere are a few setup steps before we can really use it. First we have to create a RenderScript context and use that to initialize our script. We also have to set the global variables for the script and create allocations for our input and output.\nAfter all these steps we are ready to start the calculations by calling our kernel on the loaded script.\nprivate val rs = RenderScript.create(context) private val script = ScriptC_mandelbrot(rs).apply { _width = width _height = height _maxIterations = MAX_ITER } override suspend fun generate(buffer: Bitmap, rect: RectF) { script.apply { _left = rect.left _top = rect.top _right = rect.right _bottom = rect.bottom } val bufferAllocation = Allocation.createFromBitmap(rs, buffer) script.forEach_mandelbrot(bufferAllocation, bufferAllocation) bufferAllocation.copyTo(buffer) bufferAllocation.destroy() } As there can be more than one kernels in the script we have to specify which one we would like to use by calling forEach_{{kernelName}}. As we are not using our input for anything we can also save some memory by using that for our output too.\nAfter all that we only have to copy our allocation back to a bitmap and we can display that to show our users the result.\nSo, was it worth it? Now that we’re ready with our 3 implementations we can compare them.\nWe can easily see that the easiest one to write was the Kotlin version. We had to do some extra steps to write the RenderScript version, but it was still less hassle than creating our own parallel implementation.\nAnd what about performance? To measure that I ran every computation a few times and measured the average duration it took to generate a single image. The order of the methods is as expected, Kotlin is the slowest with an average of 1016 ms/frame, the second one is the parallel version with an average of 475 ms/frame and the winner is RenderScript with an average of 33 ms/frame. Of course the numbers my vary, but we can easily see that RenderScript is the fastest by a big margin.\nIn my opinion the extra work easily worths the performance gain, but of course everybody should decide it for themselves.\nWhen should I use it? We have seen that it can be used with most efficiency when parallel computing can drastically increase the performance of our code. This is usually true for those scenarios when a large number of things should be computed and they are independent of each other.\nRenderScript (as the name suggests) is most used for image processing/manipulation, but I’m sure that there are a lot of other areas of computing where it could be used effectively.\nAnd just to have a real life example: I’m sure a lot of us had met a designer in the past who wanted some fancy blur effect for some dynamic parts of the UI which is almost impossible to achieve normally. From now on we don’t have to say that we can’t do that we just have to tell the truth:\nIt is possible, but will take longer.\nFurther reading You can read more about RenderScript on the Android Developer Site, and check out the source code of the test application at https://github.com/PsHegger/render-script-performance\n",
  "wordCount" : "2010",
  "inLanguage": "en",
  "datePublished": "2020-02-29T00:00:00Z",
  "dateModified": "2020-02-29T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "pshegger"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://pshegger.github.io/posts/renderscript/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "pshegger's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://pshegger.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://pshegger.github.io/" accesskey="h" title="pshegger&#39;s blog (Alt + H)">pshegger&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://pshegger.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://pshegger.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      RenderScript is Still alive
    </h1>
    <div class="post-description">
      RenderScript is a great way to compute large amount of data, so let&#39;s discover together what it is and when should it be considered.
    </div>
    <div class="post-meta"><span title='2020-02-29 00:00:00 +0000 UTC'>February 29, 2020</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;pshegger

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#so-what-is-renderscript" aria-label="So, what is RenderScript?">So, what is RenderScript?</a></li>
                <li>
                    <a href="#testing-method" aria-label="Testing method">Testing method</a></li>
                <li>
                    <a href="#mandelbrot" aria-label="Mandelbrot">Mandelbrot</a></li>
                <li>
                    <a href="#kotlin---the-easy-one" aria-label="Kotlin - the easy one">Kotlin - the easy one</a></li>
                <li>
                    <a href="#kotlin-parallel---the-complicated-one" aria-label="Kotlin Parallel - the complicated one">Kotlin Parallel - the complicated one</a></li>
                <li>
                    <a href="#renderscript---the-fast-one" aria-label="RenderScript - the fast one">RenderScript - the fast one</a></li>
                <li>
                    <a href="#so-was-it-worth-it" aria-label="So, was it worth it?">So, was it worth it?</a></li>
                <li>
                    <a href="#when-should-i-use-it" aria-label="When should I use it?">When should I use it?</a></li>
                <li>
                    <a href="#further-reading" aria-label="Further reading">Further reading</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>I&rsquo;m sure for most of you it&rsquo;s not a surprise, but I also think that there are people out there who either doesn&rsquo;t know what it is or simply tends to forget about it. The aim of this article is to show these people what it is and why should they use it.</p>
<h2 id="so-what-is-renderscript">So, what <em>is</em> RenderScript?<a hidden class="anchor" aria-hidden="true" href="#so-what-is-renderscript">#</a></h2>
<p>RenderScript is an Android framework which can be used for running computationally heavy tasks at high performance. You will get the most benefit on using it for tasks which require a lot of computation that can be parallelized, as the framework will run your code on every available CPU and GPU cores.</p>
<p>The first step when writing a task for RenderScript is writing the script file. This file will contain your kernel(s) and everything else needed to compute your result. The kernel is the function which will be executed on your input data in parallel. There are two type of kernels: <em>mapping</em> and <em>reduction</em>, but in this article we will only discuss the former one.</p>
<h2 id="testing-method">Testing method<a hidden class="anchor" aria-hidden="true" href="#testing-method">#</a></h2>
<p>As I mentioned before RenderScript is excellent at performing computationally heavy tasks and to demonstrate that I created a simple test application. For this test we will be generating an image of the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot set</a> using different methods. Our first version will be written in Kotlin and will not contain any optimization. The second version will still be in Kotlin but we will try to use it&rsquo;s built-in features to parallelize the computation. Lastly we will have a version written in RenderScript.</p>
<h2 id="mandelbrot">Mandelbrot<a hidden class="anchor" aria-hidden="true" href="#mandelbrot">#</a></h2>
<p>Generating an image of the Mandelbrot set is fairly easy, but it requires a lot of time. All we have to do is calculate for every pixel whether the function <code>f(z) = z*z + c</code> (where <code>z=0+0i</code> and <code>c</code> is the coordinate of the pixel mapped to the complex plane) goes to infinity or not.</p>
<p>As there is no simple way to decide that in practice we usually run a predetermined number of iterations and see if the result leaves a predetermined neighborhood of 0. This means that we can make more precise estimates with choosing a higher iteration count, but it will also slow down the process.</p>
<p>After that we just have to take the number of iterations it took to leave the neighborhood and color the pixel accordingly.</p>
<h2 id="kotlin---the-easy-one">Kotlin - the easy one<a hidden class="anchor" aria-hidden="true" href="#kotlin---the-easy-one">#</a></h2>
<p>With this knowledge we can easily write a method which calculates the color for a given coordinate.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">calculatePoint</span>(x: Int, y: Int, rect: RectF): Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> cr = rect.left + (rect.right - rect.left) * (x / width.toDouble())
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> ci = rect.top + (rect.bottom - rect.top) * (y / height.toDouble())
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> zr = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> zi = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> i = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i &lt; <span style="color:#a6e22e">MainActivity</span>.MAX_ITER <span style="color:#f92672">&amp;&amp;</span> zr * zr + zi * zi &lt; <span style="color:#ae81ff">4</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> nzr = zr * zr - zi * zi + cr
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> nzi = <span style="color:#ae81ff">2</span> * zr * zi + ci
</span></span><span style="display:flex;"><span>        zr = nzr
</span></span><span style="display:flex;"><span>        zi = nzi
</span></span><span style="display:flex;"><span>        i<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> hue = <span style="color:#ae81ff">360</span> * i.toFloat() / <span style="color:#a6e22e">MainActivity</span>.MAX_ITER
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> sat = <span style="color:#ae81ff">1f</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> value = <span style="color:#66d9ef">if</span> (i &lt; <span style="color:#a6e22e">MainActivity</span>.MAX_ITER) <span style="color:#ae81ff">1f</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0f</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Color</span>.HSVToColor(floatArrayOf(hue, sat, <span style="color:#66d9ef">value</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function can be called with the coordinate of the pixel we want to calculate (<code>x</code> and <code>y</code>) and the specific area of the plane we want to display currently (<code>rect</code>). Using these inputs we can then calculate the coordinate on the plane (<code>cr</code>and <code>ci</code>). We could also use some complex number class, but from my experience that leads to a performance drop so we stick to calculating the real and imaginary part separately. After that we just have to loop until we either reach the maximum iteration count or leave the neighborhood of 0.</p>
<p>The last step is coloring the pixel. For that the easiest way to do is using the HSV color model as you can see in the code above.</p>
<p>Now that we have everything to calculate the color of one pixel all we have to do is looping over every pixel of the output image and coloring it.</p>
<h2 id="kotlin-parallel---the-complicated-one">Kotlin Parallel - the complicated one<a hidden class="anchor" aria-hidden="true" href="#kotlin-parallel---the-complicated-one">#</a></h2>
<p>For this version will use the same function to calculate the color of one pixel, but we will split the output to multiple regions and calculate them in parallel. The number of partitions must equal to the number of threads we are using for calculation, but other than that we can split any way we would like to.</p>
<p>To determine the number of threads we will use <code>Runtime.getRuntime().availableProcessors() - 1</code>. The <code>-1</code> ensures that we have one core for our main thread. When we have the number of threads we create a <code>CoroutineDispatcher</code> and launch a new scope using that as it&rsquo;s context.</p>
<p>At this point we have to loop through our partitions and use <code>CoroutineScope.launch</code> to start the calculation on it&rsquo;s own thread. This calculation is the same as before, but we&rsquo;re just calculating the points for the given region and not for the whole image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">suspend</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">generate</span>(buffer: Bitmap, rect: RectF) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> numThreads = <span style="color:#a6e22e">Runtime</span>.getRuntime().availableProcessors() - <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> context = <span style="color:#a6e22e">Executors</span>.newFixedThreadPool(numThreads).asCoroutineDispatcher()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> h = sqrt(numThreads.toDouble()).toInt()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (numThreads % h <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) h<span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> w = numThreads / h
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> segWidth = width / w
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> segHeight = height / h
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> canvas = Canvas(buffer)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> calculation = CoroutineScope(context).launch {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (mod <span style="color:#66d9ef">in</span> (<span style="color:#ae81ff">0</span> until numThreads)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> segX = mod % w
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> segY = mod / w
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> segXStart = segWidth * segX
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> segXEnd = segWidth * (segX + <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> segYStart = segHeight * segY
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> segYEnd = segHeight * (segY + <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> paint = Paint()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>            launch {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (y <span style="color:#66d9ef">in</span> (segYStart until segYEnd)) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">for</span> (x <span style="color:#66d9ef">in</span> (segXStart until segXEnd)) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">val</span> result = calculatePoint(x, y, rect)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>                        paint.color = result
</span></span><span style="display:flex;"><span>                        canvas.drawPoint(x.toFloat(), y.toFloat(), paint)
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    calculation.join()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="renderscript---the-fast-one">RenderScript - the fast one<a hidden class="anchor" aria-hidden="true" href="#renderscript---the-fast-one">#</a></h2>
<p>As the previous example shows it can be pretty tricky to parallelize our computations. We have to manually create our threads and feed them the correct values. But this is where RenderScript comes to rescue us.</p>
<p>RenderScript will automatically manage the parallelization, all we have to do is write the function which will be executed for every input data (this will be our <code>kernel</code>). The language is a derivative of C99 so some familiarity with that is required to use it.</p>
<p>For our example all we have to write is a simple script which contains every input we will need for the calculation (width/height of the output image, the area of the plane we want to calculate and the number of iterations) and our kernel, which will be basically the same we have written in Kotlin to calculate the color of a single point. (We will also have to write a color converter, but that&rsquo;s only specific for this example.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#pragma version(1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma rs_fp_full
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma rs java_package_name(io.github.pshegger.playground.rsperformance)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> width, height;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> left, right, top, bottom;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> maxIterations <span style="color:#f92672">=</span> <span style="color:#ae81ff">128</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> uchar4 <span style="color:#a6e22e">getColor</span>(<span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> hue <span style="color:#f92672">=</span> <span style="color:#ae81ff">360</span> <span style="color:#f92672">*</span> (<span style="color:#66d9ef">float</span>) i <span style="color:#f92672">/</span> maxIterations;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> sat <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> val <span style="color:#f92672">=</span> (i <span style="color:#f92672">&lt;</span> maxIterations) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> c <span style="color:#f92672">=</span> val <span style="color:#f92672">*</span> sat;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> k <span style="color:#f92672">=</span> hue <span style="color:#f92672">/</span> <span style="color:#ae81ff">60</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> kmod <span style="color:#f92672">=</span> <span style="color:#a6e22e">fmod</span>(k, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> kmodAbs <span style="color:#f92672">=</span> (kmod <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> <span style="color:#f92672">-</span>(kmod <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> (kmod <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> x <span style="color:#f92672">=</span> c <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> kmodAbs);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> r1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, g1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, b1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(k<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> k<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">1</span>) { r1<span style="color:#f92672">=</span>c; g1<span style="color:#f92672">=</span>x; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(k<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> k<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">2</span>)  { r1<span style="color:#f92672">=</span>x; g1<span style="color:#f92672">=</span>c; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(k<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> k<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">3</span>)  { g1<span style="color:#f92672">=</span>c; b1<span style="color:#f92672">=</span>x; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(k<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">&amp;&amp;</span> k<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">4</span>)  { g1<span style="color:#f92672">=</span>x; b1<span style="color:#f92672">=</span>c; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(k<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">4</span> <span style="color:#f92672">&amp;&amp;</span> k<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">5</span>)  { r1<span style="color:#f92672">=</span>x; b1<span style="color:#f92672">=</span>c; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(k<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">5</span> <span style="color:#f92672">&amp;&amp;</span> k<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">6</span>)  { r1<span style="color:#f92672">=</span>c; b1<span style="color:#f92672">=</span>x; }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> m <span style="color:#f92672">=</span> val <span style="color:#f92672">-</span> c;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rsPackColorTo8888</span>(r1 <span style="color:#f92672">+</span> m, g1 <span style="color:#f92672">+</span> m, b1 <span style="color:#f92672">+</span> m);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>uchar4 RS_KERNEL <span style="color:#a6e22e">mandelbrot</span>(uchar4 in, <span style="color:#66d9ef">uint32_t</span> x, <span style="color:#66d9ef">uint32_t</span> y) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> nzr, nzi;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> zr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, zi <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> cr <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> (right <span style="color:#f92672">-</span> left) <span style="color:#f92672">*</span> (x <span style="color:#f92672">/</span> (<span style="color:#66d9ef">double</span>) width);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> ci <span style="color:#f92672">=</span> top <span style="color:#f92672">+</span> (bottom <span style="color:#f92672">-</span> top) <span style="color:#f92672">*</span> (y <span style="color:#f92672">/</span> (<span style="color:#66d9ef">double</span>) height);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> maxIterations <span style="color:#f92672">&amp;&amp;</span> zr <span style="color:#f92672">*</span> zr <span style="color:#f92672">+</span> zi <span style="color:#f92672">*</span> zi <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>) {
</span></span><span style="display:flex;"><span>        nzr <span style="color:#f92672">=</span> zr <span style="color:#f92672">*</span> zr <span style="color:#f92672">-</span> zi <span style="color:#f92672">*</span> zi <span style="color:#f92672">+</span> cr;
</span></span><span style="display:flex;"><span>        nzi <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> zr <span style="color:#f92672">*</span> zi <span style="color:#f92672">+</span> ci;
</span></span><span style="display:flex;"><span>        zr <span style="color:#f92672">=</span> nzr;
</span></span><span style="display:flex;"><span>        zi <span style="color:#f92672">=</span> nzi;
</span></span><span style="display:flex;"><span>        i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">getColor</span>(i);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see the kernel (marked with <code>RS_KERNEL</code>) is basically the same as was before with just some minor changes required by the language. It is also worth noting that the kernel&rsquo;s <code>x</code> and <code>y</code> parameter will not be provided by us, but the framework.</p>
<p>We have to put this file inside it&rsquo;s own directory located at <code>app/src/main/rs</code> and we will call it <code>mandelbrot.rs</code>. After saving we can build the project so the required java files will be generated and after it&rsquo;s finished we can start using it in our application.</p>
<p>There are a few setup steps before we can really use it. First we have to create a RenderScript context and use that to initialize our script. We also have to set the global variables for the script and create allocations for our input and output.</p>
<p>After all these steps we are ready to start the calculations by calling our kernel on the loaded script.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> rs = <span style="color:#a6e22e">RenderScript</span>.create(context)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> script = ScriptC_mandelbrot(rs).apply {
</span></span><span style="display:flex;"><span>    _width = width
</span></span><span style="display:flex;"><span>    _height = height
</span></span><span style="display:flex;"><span>    _maxIterations = MAX_ITER
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">suspend</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">generate</span>(buffer: Bitmap, rect: RectF) {
</span></span><span style="display:flex;"><span>    script.apply {
</span></span><span style="display:flex;"><span>        _left = rect.left
</span></span><span style="display:flex;"><span>        _top = rect.top
</span></span><span style="display:flex;"><span>        _right = rect.right
</span></span><span style="display:flex;"><span>        _bottom = rect.bottom
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> bufferAllocation = <span style="color:#a6e22e">Allocation</span>.createFromBitmap(rs, buffer)
</span></span><span style="display:flex;"><span>    script.forEach_mandelbrot(bufferAllocation, bufferAllocation)
</span></span><span style="display:flex;"><span>    bufferAllocation.copyTo(buffer)
</span></span><span style="display:flex;"><span>    bufferAllocation.destroy()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As there can be more than one kernels in the script we have to specify which one we would like to use by calling <code>forEach_{{kernelName}}</code>. As we are not using our input for anything we can also save some memory by using that for our output too.</p>
<p>After all that we only have to copy our allocation back to a bitmap and we can display that to show our users the result.</p>
<h2 id="so-was-it-worth-it">So, was it worth it?<a hidden class="anchor" aria-hidden="true" href="#so-was-it-worth-it">#</a></h2>
<p>Now that we&rsquo;re ready with our 3 implementations we can compare them.</p>
<p>We can easily see that the easiest one to write was the Kotlin version. We had to do some extra steps to write the RenderScript version, but it was still less hassle than creating our own parallel implementation.</p>
<p>And what about performance? To measure that I ran every computation a few times and measured the average duration it took to generate a single image. The order of the methods is as expected, Kotlin is the slowest with an average of <code>1016 ms/frame</code>, the second one is the parallel version with an average of <code>475 ms/frame</code> and the winner is RenderScript with an average of <code>33 ms/frame</code>. Of course the numbers my vary, but we can easily see that RenderScript is the fastest by a big margin.</p>
<p>In my opinion the extra work easily worths the performance gain, but of course everybody should decide it for themselves.</p>
<h2 id="when-should-i-use-it">When should I use it?<a hidden class="anchor" aria-hidden="true" href="#when-should-i-use-it">#</a></h2>
<p>We have seen that it can be used with most efficiency when parallel computing can drastically increase the performance of our code. This is usually true for those scenarios when a large number of things should be computed and they are independent of each other.</p>
<p>RenderScript (as the name suggests) is most used for image processing/manipulation, but I&rsquo;m sure that there are a lot of other areas of computing where it could be used effectively.</p>
<p>And just to have a real life example: I&rsquo;m sure a lot of us had met a designer in the past who wanted some fancy blur effect for some dynamic parts of the UI which is almost impossible to achieve normally. From now on we don&rsquo;t have to say that we can&rsquo;t do that we just have to tell the truth:</p>
<blockquote>
<p>It is possible, but will take longer.</p></blockquote>
<h2 id="further-reading">Further reading<a hidden class="anchor" aria-hidden="true" href="#further-reading">#</a></h2>
<p>You can read more about RenderScript on the <a href="https://developer.android.com/guide/topics/renderscript/compute">Android Developer Site</a>, and check out the source code of the test application at <a href="https://github.com/PsHegger/render-script-performance">https://github.com/PsHegger/render-script-performance</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://pshegger.github.io/tags/programming/">Programming</a></li>
      <li><a href="https://pshegger.github.io/tags/android/">Android</a></li>
      <li><a href="https://pshegger.github.io/tags/renderscript/">Renderscript</a></li>
      <li><a href="https://pshegger.github.io/tags/parallelism/">Parallelism</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share RenderScript is Still alive on x"
            href="https://x.com/intent/tweet/?text=RenderScript%20is%20Still%20alive&amp;url=https%3a%2f%2fpshegger.github.io%2fposts%2frenderscript%2f&amp;hashtags=programming%2candroid%2crenderscript%2cparallelism">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share RenderScript is Still alive on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpshegger.github.io%2fposts%2frenderscript%2f&amp;title=RenderScript%20is%20Still%20alive&amp;summary=RenderScript%20is%20Still%20alive&amp;source=https%3a%2f%2fpshegger.github.io%2fposts%2frenderscript%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share RenderScript is Still alive on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fpshegger.github.io%2fposts%2frenderscript%2f&title=RenderScript%20is%20Still%20alive">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share RenderScript is Still alive on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=RenderScript%20is%20Still%20alive&u=https%3a%2f%2fpshegger.github.io%2fposts%2frenderscript%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://pshegger.github.io/">pshegger&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
