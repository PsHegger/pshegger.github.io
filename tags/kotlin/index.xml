<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kotlin on pshegger</title>
    <link>http://pshegger.github.io/tags/kotlin/</link>
    <description>Recent content in kotlin on pshegger</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://pshegger.github.io/tags/kotlin/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Procedural Dungeon Generation</title>
      <link>http://pshegger.github.io/post/procedural-dungeon/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>http://pshegger.github.io/post/procedural-dungeon/</guid>
      <description>Procedural generation is incredible. It is the key to writing games with endless content. Without it, Minecraft couldn’t have (nearly) infinite worlds with infinite terrain. Spelunky would only contain a few rooms, and we could learn the layout and enemy placement instead of learning the game mechanics. These are only a few examples, but there are a lot of games that use this mechanic for generating content.
In this article, I’d like to show you my way of generating a random dungeon that can be later used in a game.</description>
    </item>
    
    <item>
      <title>gRPC for Kotliners</title>
      <link>http://pshegger.github.io/post/grpc-talk/</link>
      <pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://pshegger.github.io/post/grpc-talk/</guid>
      <description>This is the talk I gave at the November 2019 Kotlin Budapest meetup. You can find the slides here and the sample code at GitHub.</description>
    </item>
    
    <item>
      <title>@GenerateForMe</title>
      <link>http://pshegger.github.io/post/generate-for-me/</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://pshegger.github.io/post/generate-for-me/</guid>
      <description>Write once, use everywhere Sooner or later every developer meets the following scenario: you have written the same piece of code multiple times, maybe with some minor differences, and you don&amp;rsquo;t want to do it again. You analyze the situation and decide to create a separate function so the next time you need it you just have to call it. Sometimes it&amp;rsquo;s not enough so you create a new abstraction layer and write a class which does what you need.</description>
    </item>
    
    <item>
      <title>Help Yourself and the Compiler with Contracts</title>
      <link>http://pshegger.github.io/post/kotlin-contracts/</link>
      <pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://pshegger.github.io/post/kotlin-contracts/</guid>
      <description>What are contracts? In the world of Kotlin, contracts represent a deal between the developer and the compiler. As a developer you can share insight of your code with the compiler and it can use this extra info for better code analysis.
Currently there are two kinds of contracts available: callsInPlace which tells the compiler how many times a lambda is called, and returns/implies which indicates that a defined condition is true if the function returns a specific value.</description>
    </item>
    
  </channel>
</rss>
